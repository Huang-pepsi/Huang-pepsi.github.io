<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>操作系统学习小结 | Martin's Blog</title><meta name="author" content="Martin"><meta name="copyright" content="Martin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="想写一写操作系统的学习小结，将自己学习的思路与想法记录下来，目标是想以尽量通俗易懂的语言将一些抽象性的概念描述出来，在记录过程中会有一些不足之处，希望大家批评指正！共勉！ 操作系统的启动流程一些概念BIOS：BIOS为基本输入&#x2F;输出系统的简称，是计算机系统中的一种固件，它位于计算机的主板上，通常存储在一块可擦写的芯片中。BIOS是计算机启动时的关键组件之一，它负责初始化和检测硬件设备，启">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统学习小结">
<meta property="og:url" content="https://huang-pepsi.github.io/2023/09/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/index.html">
<meta property="og:site_name" content="Martin&#39;s Blog">
<meta property="og:description" content="想写一写操作系统的学习小结，将自己学习的思路与想法记录下来，目标是想以尽量通俗易懂的语言将一些抽象性的概念描述出来，在记录过程中会有一些不足之处，希望大家批评指正！共勉！ 操作系统的启动流程一些概念BIOS：BIOS为基本输入&#x2F;输出系统的简称，是计算机系统中的一种固件，它位于计算机的主板上，通常存储在一块可擦写的芯片中。BIOS是计算机启动时的关键组件之一，它负责初始化和检测硬件设备，启">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huang-pepsi.github.io/img/head.jpg">
<meta property="article:published_time" content="2023-09-17T04:30:06.000Z">
<meta property="article:modified_time" content="2023-09-17T04:35:27.922Z">
<meta property="article:author" content="Martin">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huang-pepsi.github.io/img/head.jpg"><link rel="shortcut icon" href="/img/11.jpg"><link rel="canonical" href="https://huang-pepsi.github.io/2023/09/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统学习小结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-17 12:35:27'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Martin's Blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Martin's Blog"><span class="site-name">Martin's Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统学习小结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-17T04:30:06.000Z" title="发表于 2023-09-17 12:30:06">2023-09-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-17T04:35:27.922Z" title="更新于 2023-09-17 12:35:27">2023-09-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>35分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统学习小结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>想写一写操作系统的学习小结，将自己学习的思路与想法记录下来，目标是想以尽量通俗易懂的语言将一些抽象性的概念描述出来，在记录过程中会有一些不足之处，希望大家批评指正！共勉！</p>
<h2 id="操作系统的启动流程"><a href="#操作系统的启动流程" class="headerlink" title="操作系统的启动流程"></a>操作系统的启动流程</h2><h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><p>BIOS：BIOS为基本输入&#x2F;输出系统的简称，是计算机系统中的一种固件，它位于计算机的主板上，通常存储在一块可擦写的芯片中。BIOS是计算机启动时的关键组件之一，它负责初始化和检测硬件设备，启动操作系统，并提供一些基本的输入&#x2F;输出功能，如键盘、显示器和磁盘驱动器的控制。</p>
<p>bootloader：bootloader(引导加载程序)是一段特殊的程序，位于计算机硬盘或其他启动设备的特定区域，负责启动操作系统的加载过程。</p>
<h3 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h3><p>计算机开机后首先执行计算机主板上固化在芯片中的BIOS程序。</p>
<p>启动后，BIOS写入内存固定地址，CPU从内存起始位置开始执行命令</p>
<p>BIOS开始执行自检，将bootloader从DISK读入内存并开始执行</p>
<p><img src="https://picx.zhimg.com/80/v2-0f3de4c90030e15140047b96d0b33671_720w.png?source=d16d100b"></p>
<p>bootloader将操作系统从DISK加载到内存中并开始执行</p>
<p><img src="https://picx.zhimg.com/80/v2-adaa3ebebefd04cd1366e13e904de8d4_720w.png?source=d16d100b"></p>
<p>（注：BIOS存放位置：BIOS是存放在主板的一块ROM芯片上，操作系统与bootloader存放在DISK中）</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="一些概念-1"><a href="#一些概念-1" class="headerlink" title="一些概念"></a>一些概念</h3><p>内存碎片：</p>
<p>1.内碎片：分配单元内未使用的内存，如进程需要100K的空间，但系统分配给进程128KB的地址空间，就会在空间内部产生28K的未使用部分，称之为内部碎片</p>
<p>2.外碎片：分配单元间未使用的内存，例如进程与进程间未被使用的空间</p>
<p>减少内存碎片两种简单方法：</p>
<p>1.压缩式：将内存中的进程向上压缩，更紧致，腾出更大空闲块。此方法内存能有效利用但开销大</p>
<p>2.交换式碎片整理：将暂时不需要运行的进程放入磁盘，此方法磁盘与内存的交互会变频繁</p>
<p>内存连续分配的几个原则：</p>
<p>1.第一匹配原则：找到内存中第一个空闲的内存块满足需求，此原则操作简单，但易于产生大空闲块，外碎片多</p>
<p>2.最佳匹配原则：找到内存中与所需分配内存差别最小的空闲块，此原则重分配慢，会很多小的外碎片</p>
<p>3.最差匹配原则：将最大的空闲块分配给新进程，此原则尽可能地减少碎片，但可能产生很多小的碎片</p>
<p>上述做法都是在内存找到连续的内存块来分配新的进程，那么当内存中没有足够的内存块来分配新进程怎么办呢？引入了分页和分段机制。</p>
<h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><p>1.什么是段：计算机进程由多个模块组成，有代码段、数据段、堆栈段、附加段等（共享库段、只读段）等，这些段就是分段需要处理的段，每个段都有自己的基址和界限信息，用于指定段在内存中的位置和大小，每个段也都有自己的标识符，通常是一个整数或字符串。</p>
<p>2.什么是段表：段表即映射逻辑地址空间的段号与实际物理地址空间的段号的映射表。通常以数组或其他数据结构的形式存在。</p>
<p>3.段表如何将逻辑地址转化为物理地址：实际上，逻辑地址转换可能涉及更多的步骤和复杂性，如权限检查、异常处理等，但基本的原理是查找段表中的表项，通过一定的计算方法计算出表项的物理地址，然后执行必要的操作。</p>
<p><img src="https://picx.zhimg.com/80/v2-9d3d898189fc1273b9e29d4679495f47_720w.png?source=d16d100b"></p>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>1.什么是页：操作系统将进程的逻辑地址空间划分成相等大小的地址空间，每个地址空间称为页，同时将物理内存划分成相同大小的页框（Page Frame）。</p>
<p>2.什么是页表：操作系统维护一个称为页表（Page Table）的数据结构，用于跟踪每个进程的页与物理内存中的页框之间的映射关系。页表的条目存储了逻辑页号与物理页框号之间的映射关系。</p>
<p>3.页的大小：分页系统中，页的大小通常是固定的，典型的页大小为4KB或更大。这个大小取决于硬件和操作系统的设计。</p>
<p>4.分页优势：</p>
<p>内存管理的简化： 分页可以简化内存管理，因为页的大小是固定的，操作系统无需处理不同大小的内存块。</p>
<p>虚拟内存支持： 分页为虚拟内存提供了基础，因为虚拟内存可以很大，使得程序可以访问超出物理内存容量的数据，而这些数据可以被交换到磁盘上。</p>
<p>隔离和保护： 分页允许操作系统为每个进程创建独立的页表，从而实现了内存隔离和进程间的保护。</p>
<p>高效的内存利用： 分页允许操作系统更有效地利用物理内存，因为它可以将物理页框动态地分配给不同的进程，以满足它们的需求。</p>
<p>5.分页与分段的优缺点比较：</p>
<p><img src="https://picx.zhimg.com/80/v2-bd9a4193d51893a117f17fe1ee3f7da5_720w.png?source=d16d100b"></p>
<p>添加图片注释，不超过 140 字（可选）</p>
<p>6.进程的页表：每个进程都有自己的页表，当进程访问虚拟地址时，操作系统通过访问页表映射到物理地址，将数据加载到正确的位置。</p>
<ol>
<li><p>一个进程对应一张页表</p>
</li>
<li><p>进程的每一页对应一个页表项</p>
</li>
<li><p>每个页表项由页号和块号组成</p>
</li>
<li><p>页表记录进程页面和实际存放的内存块之间的对应关系</p>
</li>
<li><p>每个页表项的长度是相同的</p>
</li>
</ol>
<p><img src="https://pica.zhimg.com/80/v2-0bb621b9fbcc5fc0dc6df23681d94521_720w.png?source=d16d100b"></p>
<p>页寻址机制</p>
<p>7.缺页：缺页（Page Fault）是指程序在访问虚拟内存中的某个页面时，发现该页面并未加载到物理内存中，需要将其从磁盘或其他外部存储器加载到物理内存中才能继续执行相应的指令或访问相应的数据。</p>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="进程是什么"><a href="#进程是什么" class="headerlink" title="进程是什么"></a>进程是什么</h3><p>正在运行中的程序称为进程，进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。</p>
<h3 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h3><p>1.程序代码：要执行的程序的代码。通常是二进制指令或机器码的形式。程序代码定义了进程的任务和功能。</p>
<p>2.数据：用于存储变量、数据结构等，可在进程的生命周期内被读取和修改，允许程序在运行时维护状态。</p>
<p>3.堆栈：用于管理函数调用和局部变量。堆栈是一种数据结构，用于跟踪函数的调用和返回，以及保存局部变量的状态。</p>
<p>4.程序计数器（PC）：程序计数器是一个寄存器，用于存储下一条要执行的指令的地址。在执行程序时，PC会不断更新，以指示下一个要执行的指令。</p>
<p>5.寄存器状态：进程还包含了CPU寄存器的状态。寄存器用于存储计算中间结果、标志位和其他与进程执行相关的信息。</p>
<p>6.打开文件描述符：进程可以打开文件或其他资源，每个打开的文件都会分配一个文件描述符，用于跟踪和管理对文件的访问。</p>
<p>7.进程标识符PID：每个进程有唯一的标识符。</p>
<p>8.进程状态： 进程可以处于不同的状态，如运行、就绪、阻塞等。进程状态是进程的一个重要属性，操作系统根据状态来调度进程的执行。</p>
<p>9.上下文信息： 当操作系统需要切换到另一个进程时，它必须保存当前进程的上下文信息，包括寄存器状态、程序计数器值等。这个信息被存储在操作系统的数据结构中，以便在以后重新加载。</p>
<p><img src="https://pic1.zhimg.com/80/v2-54240f91dc62eccecc532f415e4855b6_720w.png?source=d16d100b"></p>
<p>进程的上下文切换</p>
<p>10.进程控制块PCB：进程控制块是操作系统中用于管理进程的数据结构。它包含了进程的所有重要信息，包括进程的状态、上下文信息、PID、优先级等。</p>
<h3 id="进程创建时间"><a href="#进程创建时间" class="headerlink" title="进程创建时间"></a>进程创建时间</h3><p>1.系统初始化：操作系统本身也是一个进程，它在计算机启动时就会被创建。操作系统的启动过程涉及创建多个系统级别的进程，以便管理计算机的各个方面。</p>
<p>2.用户请求：用户启动一个应用程序，这是最常见的情况。</p>
<p>3.运行的进程执行创建进程的系统调用，即运行中的进程需要创建新的进程</p>
<h3 id="进程如何创建"><a href="#进程如何创建" class="headerlink" title="进程如何创建"></a>进程如何创建</h3><p><img src="https://pic1.zhimg.com/80/v2-1a7c94279d0fd192fc22fd7f29ff4dd9_720w.png?source=d16d100b"></p>
<p>内存创建流程</p>
<p>分配进程控制块PCB与进程标识符PID：OS为新进程分配一个PCB与唯一的PID，PCB 是用来存储和管理进程信息的数据结构。PID用于唯一标识系统中的每个进程。</p>
<p>分配地址空间：OS会为新进程分配一块内存空间，用于存储程序代码、数据、堆栈等信息。这通常是通过虚拟内存管理实现的。</p>
<p>初始化上下文：OS会为新进程初始化上下文信息，主要为内部寄存器信息。</p>
<p>置于就绪状态：OS会将新进程设置为就绪状态并加入就绪队列</p>
<p>这些步骤构成了进程的创建流程。需要注意的是，不同的操作系统和编程环境可能具有不同的细节和方式来创建进程，但上述步骤是通用的概括。进程的创建是操作系统中的一个复杂任务，操作系统必须有效地管理和维护进程的状态和资源，以实现多任务处理。</p>
<h3 id="进程的生命周期"><a href="#进程的生命周期" class="headerlink" title="进程的生命周期"></a>进程的生命周期</h3><p><img src="https://picx.zhimg.com/80/v2-593f3a733bae01b3f7cf7709ea223fb0_720w.png?source=d16d100b"></p>
<h3 id="进程间的通信"><a href="#进程间的通信" class="headerlink" title="进程间的通信"></a>进程间的通信</h3><p>进程通信是指在计算机系统中，不同的进程之间需要传递信息、共享数据或协同工作的一种机制。进程通信通常发生在多任务操作系统中，其中多个进程同时运行并可能需要协作完成任务。以下是一些常见的进程通信方式：</p>
<ol>
<li><p>管道（Pipe）：管道是一种单向通信机制，允许一个进程将数据写入管道，而另一个进程从同一管道读取数据。通常，一个进程充当写入者，而另一个充当读取者。</p>
</li>
<li><p>命名管道（Named Pipe）：与管道类似，但允许不同进程通过共享的命名管道进行通信，而不仅仅是父子进程之间。</p>
</li>
<li><p>消息队列（Message Queue）：消息队列允许进程通过发送消息进行通信。这些消息可以包含数据以及用于标识消息类型或目标进程的信息。</p>
</li>
<li><p>信号（Signal）：信号是一种用于通知进程发生某些事件的机制。例如，一个进程可以向另一个进程发送信号，通知它应该终止或重新启动。</p>
</li>
<li><p>共享内存（Shared Memory）：共享内存允许多个进程共享同一块物理内存区域。这使得数据可以直接从一个进程传递到另一个进程，而无需复制数据。</p>
</li>
<li><p>套接字（Socket）：套接字是一种网络通信的方式，但也可以用于本地进程之间的通信。通过套接字，进程可以在不同计算机上或同一计算机上的不同端口进行通信。</p>
</li>
<li><p>信号量（Semaphore）：信号量是一种用于控制对共享资源的访问的机制。进程可以使用信号量来协调对共享资源的访问，以防止竞争条件。</p>
</li>
<li><p>文件（File）：进程可以通过读写共享文件来进行通信。一个进程可以将数据写入文件，而另一个进程可以从同一文件读取数据。</p>
</li>
<li><p>远程过程调用（RPC）和进程间通信（IPC）：这些是高级通信机制，允许远程计算机上的进程相互调用函数或方法，并通过网络传递数据。</p>
</li>
</ol>
<p>选择哪种进程通信方式取决于应用程序的需求和设计，以及操作系统提供的支持。不同的通信方式有不同的复杂性和性能特性，开发人员需要谨慎选择以满足特定场景的需求。</p>
<h3 id="进程阻塞原因"><a href="#进程阻塞原因" class="headerlink" title="进程阻塞原因"></a>进程阻塞原因</h3><p>1.请求数据未到达</p>
<p>2.等待系统调用</p>
<p>3.启动某种操作，无法马上执行</p>
<h3 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h3><p>线程是进程（Process）内部的一条执行路径。线程是操作系统能够进行调度和执行的最小单位，它包含了在进程中执行的指令序列和相关的数据。每个进程可以包含一个或多个线程，这些线程可以并发执行，共享进程的资源和内存空间。</p>
<h3 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h3><p>进程是资源分配的基本单位，线程是CPU调度的基本单位</p>
<p>单独性：</p>
<p>进程是独立的执行单元，拥有自己的独立内存空间和资源。每个进程都有自己的代码、数据和堆栈。进程与进程间是一般是互相隔离的。</p>
<p>线程是进程内的子执行单元，多个线程属于同一个进程，共享进程的内存空间和资源。</p>
<p>切换开销：</p>
<p>由于进程有独立的内存空间，进程之间的切换开销较大，需要保存和恢复大量的上下文信息。</p>
<p>线程之间的切换开销较小，因为它们共享相同的内存空间，上下文切换通常只需要保存和恢复寄存器的值，线程上下文切换不需要改变地址空间（不需要切换当前的虚拟内存空间或使用的页表）。</p>
<p>通信和同步：</p>
<p>进程之间通信较为复杂，通常需要使用进程间通信（IPC）机制，如管道、消息队列、共享内存等，来实现数据交换。</p>
<p>线程之间通信更容易，可以直接读写共享内存，但也需要注意同步问题，以避免竞态条件和数据一致性问题</p>
<p>创建和销毁成本：</p>
<p>创建和销毁进程的成本较高，因为每个进程都需要分配独立的内存空间和资源。</p>
<p>创建和销毁线程的成本较低，因为它们共享进程的资源，只需要分配一些额外的栈空间即可</p>
<p>安全性：</p>
<p>由于进程拥有独立的内存空间，进程之间更加隔离，一个进程的崩溃通常不会影响其他进程。</p>
<p>线程共享相同的内存空间，一个线程的错误可能会影响整个进程，导致进程崩溃（缺陷）。</p>
<h3 id="线程的组成"><a href="#线程的组成" class="headerlink" title="线程的组成"></a>线程的组成</h3><p>线程是计算机程序执行的最小单位，它由多个组成部分组成，这些部分协同工作以执行线程的任务。以下是线程的主要组成部分：</p>
<ol>
<li><p>线程ID（Thread ID）：线程ID是唯一标识一个线程的数字或标识符。它允许操作系统和程序来区分不同的线程。</p>
</li>
<li><p>寄存器集合（Register Set）：每个线程都有自己的寄存器集合，包括通用寄存器、程序计数器（PC）等。寄存器用于存储线程执行时的临时数据和状态信息。</p>
</li>
<li><p>栈（Stack）： 每个线程都有自己的栈，用于存储函数调用和局部变量。栈是一个后进先出（LIFO）数据结构，用于跟踪函数的调用和返回。</p>
</li>
<li><p>线程局部存储（Thread-Local Storage，TLS）：线程局部存储是线程私有的内存区域，用于存储线程特定的数据，这些数据对于其他线程不可见。线程局部存储通常用于保存线程的状态信息或其他线程无法共享的数据。</p>
</li>
<li><p>线程控制块（Thread Control Block，TCB）：线程控制块是操作系统维护的数据结构，用于存储线程的状态信息和管理线程的执行。TCB 包含线程的状态、优先级、寄存器值、线程ID等信息。</p>
</li>
<li><p>线程优先级（Thread Priority）：线程通常具有优先级，用于确定线程在竞争CPU时间时的执行顺序。较高优先级的线程可能会在较低优先级的线程之前执行。</p>
</li>
<li><p>线程状态（Thread State）：线程可以处于不同的状态，如运行、就绪、阻塞等。线程状态用于描述线程当前的执行情况。</p>
</li>
<li><p>线程同步机制：线程可能需要进行同步操作以避免竞态条件和数据访问冲突。线程同步机制包括互斥锁、信号量、条件变量等，用于控制线程的访问和操作共享资源。</p>
</li>
</ol>
<p>这些组成部分协同工作，使线程能够执行任务并与其他线程共享数据和资源。线程的创建、调度、销毁和同步等操作都受线程的组成部分和线程控制块的管理。理解线程的组成部分有助于开发者编写多线程程序并有效地管理线程的行为。</p>
<h3 id="处理机调度概念"><a href="#处理机调度概念" class="headerlink" title="处理机调度概念"></a>处理机调度概念</h3><p>处理机调度是操作系统的核心功能之一，它负责决定在多个就绪状态的进程或线程之间分配CPU时间片，以实现公平共享CPU资源，提高系统的性能和响应速度。以下是处理机调度的一些关键概念和方法：</p>
<p>调度队列（Scheduling Queue）:调度队列通常指的是在计算机操作系统中用于管理和执行进程的一种数据结构。它是一个按照一定的策略来安排和分配CPU时间的队列。调度队列的目的是优化资源的利用，确保系统能够高效地运行多个任务。</p>
<p>优先级（Priority）：在操作系统中，优先级调度是一种调度算法，它根据任务的优先级来分配CPU时间。每个任务都被分配一个优先级值，通常是一个整数，数值越小表示优先级越高。当系统中有多个任务需要执行时，优先级高的任务将会先被执行。</p>
<p>抢占性（Preemption）：抢占性是指操作系统可以在一个进程或任务还未完成时，剥夺其正在使用的CPU资源，将CPU资源分配给具有更高优先级的另一个进程或任务的能力。</p>
<p>在抢占性调度中，操作系统会根据某些规则（如优先级或时间片）来决定是否暂停当前正在执行的任务，并将CPU资源分配给另一个任务。这使得高优先级任务能够及时响应并执行，而不会被低优先级任务长时间占用CPU。</p>
<p>多核调度、实时调度（Real-Time Scheduling）、调度策略（Scheduling Policies）、上下文切换（Context Switching）</p>
<h3 id="处理机调度策略"><a href="#处理机调度策略" class="headerlink" title="处理机调度策略"></a>处理机调度策略</h3><p>先来先服务调度（First-Come, First-Served，FCFS）：按照进程到达的顺序分配CPU时间片。FCFS通常用于处理任务或进程的顺序，其中任务按照它们到达系统或队列的顺序来执行，最先到达的任务首先被处理，直到完成或等待某种事件发生后才进行下一个任务。</p>
<p>优缺点：简单且公平，但可能导致长作业等待时间。</p>
<p>最短作业优先调度（Shortest Job First，SJF）：选择估计执行时间最短的进程或线程先执行。（非抢占式）若在进程A进行过程中到来进程B和C，则比较BC的运行时间长短，等待A一直运行到结束，选择执行时间最短的任务。（抢占式）系统可以在任何时刻中断当前执行的任务，如果有一个更短的任务到达就绪队列，系统会立即切换到该任务。这种方式需要动态地监测任务的执行时间，并在需要时进行切换。</p>
<p>优缺点：最小化平均等待时间，但需要准确的执行时间估计。</p>
<p>轮转调度（Round Robin，RR）：将CPU时间划分成固定大小的时间片，每个进程或线程执行一个时间片，然后排到队列的末尾。</p>
<p>优缺点：公平分配CPU时间，适用于时间共享系统，但可能导致上下文切换开销。</p>
<p>优先级调度（Priority Scheduling）：</p>
<p>为每个进程或线程分配一个优先级，高优先级的先执行。</p>
<p>优缺点：可以根据任务的重要性分配优先级，但可能导致低优先级任务饥饿。</p>
<p>多级反馈队列调度（Multilevel Feedback Queue，MLFQ）：</p>
<p>将进程分为多个队列，每个队列有不同的优先级，新进程进入最高优先级队列。</p>
<p>根据进程的行为和性能动态调整队列和优先级，适用于多样化的工作负载。</p>
<h3 id="处理机调度准则"><a href="#处理机调度准则" class="headerlink" title="处理机调度准则"></a>处理机调度准则</h3><p>处理机调度是操作系统中的一个重要任务，它决定了在多个进程之间如何分配处理机时间，以最大程度地提高系统的吞吐量、响应时间和效率。不同的调度算法和准则可以用来实现不同的性能目标，以下是一些常见的处理机调度准则：</p>
<ol>
<li><p>公平性（Fairness）：确保每个进程都能获得公平的处理机时间，以防止某个进程长时间占用处理机而导致其他进程无法运行。</p>
</li>
<li><p>优先级（Priority）：为每个进程分配一个优先级，高优先级的进程在竞争处理机时间时会被优先考虑。这可以用于确保关键任务得到及时处理。</p>
</li>
<li><p>短作业优先（Shortest Job First，SJF）：优先选择估计执行时间最短的进程，以最小化平均等待时间。这需要对进程的执行时间有良好的估计。</p>
</li>
<li><p>轮转（Round Robin）：按照固定时间片（时间片轮转）或时间片可变（多级反馈队列）的方式分配处理机时间，以确保每个进程都有机会运行。这种方法适用于多任务系统。</p>
</li>
<li><p>多级队列（Multilevel Queue）：将进程分为多个队列，每个队列具有不同的优先级，不同队列之间采用不同的调度算法。例如，高优先级队列可能采用SJF调度，而低优先级队列采用轮转调度。</p>
</li>
<li><p>最早截止时间优先（Earliest Deadline First，EDF）：为每个进程分配一个截止时间，选择下一个要执行的进程时优先考虑截止时间最早的进程，以确保实时任务按时完成。</p>
</li>
<li><p>响应时间（Response Time）：优先选择能够更快响应用户输入或事件的进程，以提高系统的交互性能。</p>
</li>
<li><p>负载均衡（Load Balancing）：在多处理器系统中，调度器可以尝试将进程分配到不同的处理器上，以确保系统资源充分利用。</p>
</li>
<li><p>静态调度和动态调度：静态调度是在编译或系统启动时确定进程的调度顺序，而动态调度是在运行时根据系统的状态和进程的特性进行调度决策。</p>
</li>
</ol>
<p>不同的应用场景和系统要求可能需要不同的调度准则和算法。操作系统的调度器通常会根据实际情况选择合适的调度策略来满足性能需求。</p>
<h3 id="进程间的制约关系"><a href="#进程间的制约关系" class="headerlink" title="进程间的制约关系"></a>进程间的制约关系</h3><p>在多进程或多线程的计算机程序中，进程之间可以存在不同的制约关系，这些关系可以影响进程的执行顺序、资源共享和数据一致性。以下是一些常见的进程间制约关系：</p>
<ul>
<li><p>竞争条件（Race Condition）：竞争条件发生在多个进程试图同时访问共享资源时，而没有适当的同步机制来保护这些资源。这可能导致不可预测的结果和数据不一致。</p>
</li>
<li><p>互斥（Mutual Exclusion）：互斥关系是指多个进程不能同时进入临界区（访问共享资源的关键部分）。通过互斥锁或信号量等同步机制，可以确保只有一个进程能够进入临界区，从而防止竞争条件。</p>
</li>
<li><p>有序执行（Ordering Constraint）：有时，程序需要确保一些操作按照特定的顺序执行。例如，一个进程可能需要等待另一个进程完成某个操作后才能执行。</p>
</li>
<li><p>死锁（Deadlock）：死锁是一种进程间制约关系，其中多个进程都在等待对方释放某个资源，从而导致所有进程都无法继续执行。解决死锁问题需要谨慎地设计同步机制和资源管理策略。</p>
</li>
<li><p>优先级（Priority）：某些情况下，进程的执行顺序受其优先级的影响。高优先级的进程可能会在低优先级的进程之前执行。</p>
</li>
<li><p>依赖关系（Dependency）：多个进程之间可能存在依赖关系，其中一个进程必须等待另一个进程完成某项任务才能继续执行。这通常涉及到任务的协同工作。</p>
</li>
<li><p>通信（Communication）：进程之间可能需要进行通信以共享信息或传递数据。通信可以通过消息传递、共享内存等方式实现，并可能受到同步和顺序的影响。</p>
</li>
<li><p>条件等待（Conditional Wait）：某些情况下，一个进程可能需要等待某个条件满足后才能继续执行。这通常涉及到条件变量和等待&#x2F;通知机制。</p>
</li>
<li><p>饥饿（Starvation）：饥饿是指一个或多个进程由于长时间无法获得所需的资源或执行时间而无法继续执行。这可能由于优先级不当或竞争资源导致。</p>
</li>
</ul>
<h3 id="进程同步的概念"><a href="#进程同步的概念" class="headerlink" title="进程同步的概念"></a>进程同步的概念</h3><p>进程同步用于协调多个并发执行的进程或线程之间的操作，以确保数据的一致性和正确性。在多任务和多进程的操作系统中，进程同步非常关键，因为多个进程可能同时访问共享资源，如内存、文件、设备等，如果没有适当的同步机制，就会导致竞态条件和数据不一致的问题。</p>
<p>进程同步的目标是避免竞态条件（Race Condition）、死锁（Deadlock）、饥饿（Starvation）和优先级反转（Priority Inversion）等问题，以确保多个进程能够协作并正确地访问共享资源。</p>
<h3 id="信号量的概念"><a href="#信号量的概念" class="headerlink" title="信号量的概念"></a>信号量的概念</h3><p>信号量（Semaphore）是一种用于多进程或多线程编程中的同步工具，它用于控制对共享资源的访问。信号量可以帮助解决多个进程或线程之间的竞争条件，确保对共享资源的访问是有序和同步的。</p>
<p>信号量的基本概念包括以下几个要点：</p>
<ul>
<li><p>计数器：信号量是一个整数计数器，通常初始化为非负整数。这个计数器用来表示可用资源的数量或者某种条件的状态。</p>
</li>
<li><p>原子操作：对信号量的操作必须是原子操作，即不会被中断的操作。这确保了多个进程或线程同时尝试修改信号量时不会导致竞态条件。</p>
</li>
<li><p>等待和释放：信号量提供两种基本操作：等待（wait）和释放（post）。</p>
</li>
<li><p>等待操作：当一个进程或线程希望访问某个共享资源时，它首先执行等待操作。如果信号量的计数器大于零，那么等待操作会减少计数器的值，并允许进程或线程继续执行。如果计数器为零，等待操作可能会阻塞（挂起）进程或线程，直到计数器变为大于零为止。</p>
</li>
<li><p>释放操作：当一个进程或线程完成对共享资源的访问后，它执行释放操作，这会增加信号量的计数器。这样，其他等待资源的进程或线程可以继续执行。</p>
</li>
<li><p>控制资源访问：通过适当调整信号量的初始值和执行等待&#x2F;释放操作的时机，可以实现对共享资源的访问控制。例如，可以用信号量来限制同时访问某个共享资源的进程或线程数量。</p>
</li>
</ul>
<h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h3><p>它发生在多个进程或线程之间，每个都在等待某个事件或资源，但这些事件或资源互相依赖，导致所有进程或线程都无法继续执行的情况。简而言之，死锁是一种互相等待的僵局，阻塞了程序的进一步执行。</p>
<h3 id="死锁触发的条件"><a href="#死锁触发的条件" class="headerlink" title="死锁触发的条件"></a>死锁触发的条件</h3><ul>
<li><p>互斥条件（Mutual Exclusion）：至少有一个资源是互斥的，即只能被一个进程或线程占用，其他进程或线程必须等待释放。</p>
</li>
<li><p>持有与等待条件（Hold and Wait）：进程或线程至少持有一个资源，并等待获取其他资源，这时候如果其他资源正好被其他进程或线程占用，就会发生死锁。</p>
</li>
<li><p>不可剥夺条件（No Preemption）：资源不能被强制剥夺，只能由持有它的进程或线程主动释放。</p>
</li>
<li><p>环路等待条件（Circular Wait）：存在一个等待链，每个进程或线程都在等待下一个进程或线程释放资源，形成一个环路等待情况。</p>
</li>
</ul>
<h3 id="解决死锁策略"><a href="#解决死锁策略" class="headerlink" title="解决死锁策略"></a>解决死锁策略</h3><ol>
<li><p>资源分配策略：设计合理的资源分配策略，确保不会出现持有与等待和环路等待条件。例如，一种常见的策略是要求进程在开始执行之前一次性获取所有需要的资源，以防止持有与等待。</p>
</li>
<li><p>资源预分配：在系统初始化或运行时，为每个进程分配所需的资源，而不是等待进程请求资源。这种方法可以避免持有与等待条件。</p>
</li>
<li><p>资源优先级：给资源分配优先级，确保资源会被高优先级的进程或线程剥夺，并重新分配给其他进程。</p>
</li>
<li><p>超时机制：为等待资源的进程或线程设置超时，如果超时，则放弃等待或采取其他措施。</p>
</li>
<li><p>死锁检测与恢复：定期检测系统中是否存在死锁，一旦检测到死锁，采取措施中断其中一个进程或线程，以解除死锁。</p>
</li>
<li><p>避免共享资源：尽量减少共享资源的使用，或者使用无锁数据结构和算法，以减少发生死锁的机会。</p>
</li>
</ol>
<h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><h3 id="设备的概念与分类"><a href="#设备的概念与分类" class="headerlink" title="设备的概念与分类"></a>设备的概念与分类</h3><p>“设备”泛指计算机系统中的各种外部设备，即主机以外的其他所有设备。外部设备品种繁多，功能各异，对它们管理的好坏，会直接影响到整个系统的效率。</p>
<p>按分配特性分：</p>
<p>独享设备：一次只能分配给一个进程使用，常见有打印机。</p>
<p>共享设备：可以由几个用户进程交替地对它进行信息的读或写操作，常见有磁盘。</p>
<p>虚拟设备：把独享设备“改造”成为可以共享的设备，但实际上这种共享设备是不存在的，常见有虚拟网卡、虚拟磁盘等。</p>
<p>按功能分：</p>
<p>字符设备：一种在操作系统中表示以字符为单位进行读写的设备。如键盘、鼠标、串口、打印机等，与块设备相比，字符设备不会缓冲数据，而是将数据直接传输给设备或者从设备获取数据。这使得字符设备更适合处理以字符为单位的输入和输出操作。</p>
<p>优缺点：不需要缓存、低延时、灵活性高。但效率低（可能需要频繁读取）、不适合大量数据传输、不支持随机访问。</p>
<p>块设备：一种在操作系统中表示以固定大小的块（通常为512字节）为单位进行读写的设备。如硬盘、SD卡、CD&#x2F;DVD驱动器等，块设备的特点是能够以相对较高的速率进行数据传输，因为它们以较大的数据块为单位进行操作，而不是单个字符。这使得块设备适用于需要大量数据传输的场景，比如文件系统的读写操作。</p>
<p>优缺点：能大量传输数据、支持随机访问、支持缓存。复杂度高、不能实时响应。</p>
<h3 id="如何完成一个IO请求"><a href="#如何完成一个IO请求" class="headerlink" title="如何完成一个IO请求"></a>如何完成一个IO请求</h3><p>一些概念：</p>
<p>1.设备管理器：是操作系统中的一个系统工具或应用程序，用于管理计算机硬件设备。</p>
<p>2.设备驱动程序：是一种软件程序，它允许操作系统与硬件设备进行通信和控制。设备驱动程序充当操作系统与硬件之间的中介，使得操作系统可以通过标准接口来访问和控制各种硬件设备，而无需了解硬件的具体细节。简单地说，设备驱动程序将硬件设备抽象化，隐藏硬件细节，向操作系统提供接口。设备驱动程序的编写需要对硬件的特性和操作系统的接口有深入的了解。</p>
<p>3.设备控制器：与CPU进行交互，处理各种传入传出信号的硬件，内部有不同种类的寄存器来进行设备发送数据，接收数据、开启或者关闭等。每个设备控制器都会有一个应用程序与之对应，设备控制器通过应用程序的接口通过中断与操作系统进行通信。设备控制器是硬件，而设备驱动程序是软件。</p>
<p>步骤分析：</p>
<p>用户在程序中使用系统提供的输入&#x2F;输出命令发出I&#x2F;O请求——&gt;输入&#x2F;输出管理程序接受这个请求——&gt;设备驱动程序来具体完成所要求的 I&#x2F;O操作——&gt;设备中断处理程序来处理这个请求</p>
<p>1.I&#x2F;O请求来自用户作业进程。比如在某个进程的程序中使用系统提供的I&#x2F;O命令形式为READ（input,buffer,n）,它表示要求通过输入设备input，读入n个数据到由buffer指明的内存缓冲区中。</p>
<p>2.输入&#x2F;输出管理程序一方面从用户程序那里接受I&#x2F;O请求，另一方面把I&#x2F;O请求交给设备驱动程序去具体完成，因此起到一个桥梁的作用。输入&#x2F;输出管理程序首先接受用户对设备的操作请求，并把发出请求的进程由原来的运行状态改变为阻塞状态。如果当前设备空闲，那么管理程序验证了 I&#x2F;O 请求的合法性（比如不能对输入设备发输出命令，不能对输出设备发输入命令等）后，就把这个设备分配给该用户进程使用，调用设备驱动程序，去完成具体的输入&#x2F;输出任务。在整个 I&#x2F;O 操作完成之后，管理程序控制由设备驱动程序返回到输入输出管理程序，把等待这个 I&#x2F;O 完成的进程从阻塞队列上摘下来，并把它的状态由阻塞变为就绪，到就绪队列排队，再次参与对CPU的竞争。因此，设备的输入&#x2F;输出管理程序由3块内容组成：接受用户的I&#x2F;O请求，组织管理输入&#x2F;输出的进行，以及输入&#x2F;输出的善后处理。</p>
<p>3.在从输入&#x2F;输出管理程序手中接过控制权后，设备驱动程序就读出设备状态，判定其完好可用后，就直接向设备发出 I&#x2F;O 硬指令。在多道程序系统中，设备驱动程序一旦启动了一个I&#x2F;O操作，就让出对CPU的控制权，以便在输入&#x2F;输出设备忙于进行I&#x2F;O操作时，CPU能脱身去做其他的事情，从而提高处理机的利用率。</p>
<p>4.在设备完成一次输入&#x2F;输出操作之后，是通过中断来告知 CPU 的。当 CPU 接到来自 I&#x2F;O设备的中断信号后，就去调用该设备的中断处理程序。</p>
<h3 id="为什么进行设备管理"><a href="#为什么进行设备管理" class="headerlink" title="为什么进行设备管理"></a>为什么进行设备管理</h3><ul>
<li><p>操作系统设备管理的目标之一，是提高外部设备的利用率。在多道程序设计环境下，外部设备的数量肯定少于用户进程数，竞争不可避免。因此在系统运作过程中，如何合理地分配外部设备，协调它们之间的关系，如何充分发挥外部设备之间、外部设备与CPU之间的并行工作能力，使系统中的各种设备尽可能地处于忙碌状态，显然是一个非常重要的问题。</p>
</li>
<li><p>操作系统设备管理的目标之二是为用户提供便利、统一的使用界面。“界面”是用户与设备进行交流的手段。计算机系统配备的外部设备类型多样，特性不一，操作各异。操作系统必须把各种外部设备的物理特性隐藏起来，把各种外部设备的操作方式隐藏起来，这样，用户使用时才会感到便利，才会感到统一。</p>
</li>
</ul>
<h3 id="如何进行设备管理"><a href="#如何进行设备管理" class="headerlink" title="如何进行设备管理"></a>如何进行设备管理</h3><p><img src="https://picx.zhimg.com/80/v2-fb659fd1af3421c29b6e1a6a77006043_720w.png?source=d16d100b"></p>
<p>DCB（设备控制块）</p>
<p>设备控制块作用：</p>
<ol>
<li><p>设备状态追踪：DCB 会记录设备的状态信息，比如设备是否处于空闲状态、是否正在执行某个操作等。</p>
</li>
<li><p>设备控制：DCB 可以包含控制设备的信息，比如控制设备开始读取或写入数据。</p>
</li>
<li><p>缓冲区管理：DCB 可能会包括一个或多个缓冲区，用于暂存数据。例如，当你向打印机发送数据时，通常会先将数据写入一个缓冲区，然后再由打印机逐步处理。</p>
</li>
<li><p>中断处理：DCB 可能会包含一些用于处理设备中断的信息，以便及时响应设备事件。</p>
</li>
<li><p>错误处理：DCB 可以记录设备操作过程中发生的错误信息，以便系统能够采取相应的措施，比如重新尝试、报告错误等。</p>
</li>
<li><p>设备标识：DCB 包括了用于唯一标识设备的信息，以便操作系统能够正确地识别和管理不同的设备。</p>
</li>
</ol>
<p>设备管理步骤：</p>
<p><img src="https://pic1.zhimg.com/80/v2-42b2b4bb25045cf37223d6065050bcb8_720w.png?source=d16d100b"></p>
<p>操作系统对字符设备进行管理步骤</p>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><p>文件管理可从两方面看—文件和文件的管理，也就引申出什么是文件，文件组织方式（结构），操作系统如何对文件进行管理、调度。</p>
<p>前面介绍的存储管理和处理机管理，它们涉及的管理对象都是计算机系统中的硬件资源，即中央处理机（CPU）和内存储器(Memory)。计算机系统中还有一类资源，即软件资源，对它们的管理，要由操作系统中的“文件管理”来完成。</p>
<p>内存中的数据在断电时会丢失，如何将数据持久地存储，引入了文件管理的概念。由于系统的内存有限且不能长期保存，故将文件存放在外存中，到需要时再调入内存使用，需要操作系统高效地进行文件管理。</p>
<h3 id="什么是文件"><a href="#什么是文件" class="headerlink" title="什么是文件"></a>什么是文件</h3><p>定义：所谓“文件”，是指具有完整逻辑意义的一组相关信息的集合，它保存在磁盘上，可进行读取与修改等操作。</p>
<h3 id="文件的类型有哪些"><a href="#文件的类型有哪些" class="headerlink" title="文件的类型有哪些"></a>文件的类型有哪些</h3><p>文件按照不同的分类标准可进行不同的分类，下面列举几个常见分类标准：</p>
<p>按文件的性质和用途：</p>
<p>（1）系统文件：操作系统及其他系统程序（如语言的编译程序）构成系统文件的范畴。这些文件通常是可执行的目标代码及所访问的数据，用户对它们只能执行，没有读和写的权利。</p>
<p>（2）用户文件：用户文件是用户在软件开发过程中产生的各种文件，如源程序、目标程序代码和计算结果等。这些文件只能由文件主和被授权者使用。</p>
<p>（3）库文件：常用的标准子程序（如求三角函数sin、cos的子程序）、实用子程序（如对数据进行排序的子程序）等组成库文件。库文件中的文件，用户在开发过程中可以直接调用，不过用户对这些文件只能读取或执行，不能修改。</p>
<p>按文件的保护性质：</p>
<p>（1）只读文件：只允许查看的文件为只读文件。对于只读文件，使用者不能对它们进行修改，也不能运行。</p>
<p>（2）读写文件：这是一种允许查看和修改的文件，但不能运行。</p>
<p>（3）可执行文件：这是一种可以在计算机上运行的文件，以期完成特定的功能。使用者不能对它进行查看和修改。</p>
<p>（4）不保护文件：这是一种不设防的文件，可以任意对它进行使用、查看和修改。</p>
<h3 id="文件如何使用"><a href="#文件如何使用" class="headerlink" title="文件如何使用"></a>文件如何使用</h3><p>1.文件的共享</p>
<p>文件有两种共享方式：1.任一时刻只能有一个用户对文件进行操作 2.多个用户能同时对一个文件进行读操作</p>
<p>2.文件的保护</p>
<p>文件保护是指要防止未经授权的用户使用文件，也要防止文件主自己错误地使用文件而给文件带来破坏。通常，可以采用存取控制矩阵、存取控制表、权限表和口令等方法，来达到保护文件不受侵犯的目的。</p>
<p>3.文件的备份</p>
<p>为防止数据的意外丢失，需要对文件进行备份。</p>
<p>4.文件的操作</p>
<p>对于文件的操作主要有创建、删除、读取、写入、关闭。</p>
<h3 id="文件的存储方式"><a href="#文件的存储方式" class="headerlink" title="文件的存储方式"></a>文件的存储方式</h3><p>存取方式可以作为文件的分类依据。用户在访问文件时，常采用顺序存取和随机存取（也称直接存取）两种方式。</p>
<h3 id="文件管理是什么"><a href="#文件管理是什么" class="headerlink" title="文件管理是什么"></a>文件管理是什么</h3><p>那么，用户在以“按名存取”的方式，对自己的文件进行访问时，系统如何知道这个文件存放在哪里，如何得到有关这个文件的各种信息，以便完成用户的读&#x2F;写请求，这些涉及到对具体文件的管理问题。系统是通过文件的目录来管理文件的。</p>
<h3 id="如何进行文件管理"><a href="#如何进行文件管理" class="headerlink" title="如何进行文件管理"></a>如何进行文件管理</h3><p>一些概念：</p>
<p>1.文件控制块（FCB）</p>
<p>操作系统都是通过各种“控制块”对具体的管理对象实施管理的，比如进程控制块（PCB）、作业控制块（JCB）和设备控制块（DCB）等。对于文件，操作系统仍然采用这种老办法来管理。即为每一个文件开辟一个存储区，在它的里面记录着该文件的有关信息，我们把该存储区称为“文件控制块（FCB）”。于是，找到一个文件的 FCB，也就得到了这个文件的有关信息，就能够对它进行所需要的操作了。</p>
<p>FCB是计算机操作系统中用于管理文件的一种数据结构。它包含了关于文件的各种信息，以便于操作系统进行文件的读取、写入和管理。包含具体信息如下：</p>
<ul>
<li><p>文件名和扩展名：标识文件的唯一名称。</p>
</li>
<li><p>文件类型：指示文件的类型（例如文本文件、二进制文件等）。</p>
</li>
<li><p>文件属性：包括文件是否只读、隐藏等属性。</p>
</li>
<li><p>文件大小：指示文件所占用的存储空间大小。</p>
</li>
<li><p>文件位置：指示文件在存储介质上的物理位置。</p>
</li>
<li><p>访问权限：包括读取、写入、执行等权限。</p>
</li>
<li><p>创建日期和时间：记录文件创建的具体日期和时间。</p>
</li>
<li><p>修改日期和时间：记录文件最后一次修改的日期和时间。</p>
</li>
<li><p>访问日期和时间：记录文件最后一次被访问的日期和时间。</p>
</li>
<li><p>文件指针：用于指示当前读写位置，以便于在文件中进行定位和操作。</p>
</li>
</ul>
<p>2.文件目录（File Catalog）</p>
<p>把文件的文件控制块汇集在一起，就形成了系统的文件目录，每个文件控制块就是一个目录项，其中包含了该文件的文件名、文件属性，以及文件的数据在磁盘上的地址等信息。</p>
<p>一级目录结构：在系统只创建一张目录表，所有的文件都存放在这个目录表下。</p>
<p>优点：方便、直观。</p>
<p>弊端：当文件过多时，此结构不利于文件的创建、查找，由于文件不能重名，用户之间的操作容易产生冲突。</p>
<p>二级目录结构：在主目录下有多个用户目录，每个用户目录拥有自己的子文件。</p>
<p>优点：用户之间可以取重名文件，缩短了按名查找文件的时间。</p>
<p>弊端：但是，如果一个用户拥有很多的文件，那么在他的目录中进行查找，所花费的时间仍然会很长。另外，在二级目录结构中，用户无法对自己的文件进行再分类安排。所以，这种目录结构还是难以使用户感到满意。</p>
<p>树型目录结构：主目录下的每个用户目录可以有多个子目录，每个子目录又可以拥有多个子目录。</p>
<p>优点：大大缩短了查找文件的时间，结构清晰化。</p>
<p>弊端：处理大量文件时会造成目录的变化，此时需要调整树的结构。可能会导致深层的树形结构，是文件路径变长。当需要在已有的树型结构中添加新的分类或主题时，可能需要对整个结构进行调整，这可能会导致混乱。</p>
<p><img src="https://pica.zhimg.com/80/v2-a71d3807895f6e3c60b1a0590cd528da_720w.png?source=d16d100b"></p>
<p>树型目录</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huang-pepsi.github.io">Martin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huang-pepsi.github.io/2023/09/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/">https://huang-pepsi.github.io/2023/09/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://huang-pepsi.github.io" target="_blank">Martin's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/09/17/Qt%E7%9A%84Pro%E6%96%87%E4%BB%B6%E5%B0%8F%E7%BB%93/" title="Qt的Pro文件小结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Qt的Pro文件小结</div></div></a></div><div class="next-post pull-right"><a href="/2023/09/16/First-Post/" title="first post"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">first post</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Valine</span><span id="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Martin</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">操作系统的启动流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">一些概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">启动流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5-1"><span class="toc-number">2.1.</span> <span class="toc-text">一些概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AE%B5"><span class="toc-number">2.2.</span> <span class="toc-text">分段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%A1%B5"><span class="toc-number">2.3.</span> <span class="toc-text">分页</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.1.</span> <span class="toc-text">进程是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">3.2.</span> <span class="toc-text">进程的组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%97%B6%E9%97%B4"><span class="toc-number">3.3.</span> <span class="toc-text">进程创建时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA"><span class="toc-number">3.4.</span> <span class="toc-text">进程如何创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.5.</span> <span class="toc-text">进程的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">3.6.</span> <span class="toc-text">进程间的通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%98%BB%E5%A1%9E%E5%8E%9F%E5%9B%A0"><span class="toc-number">3.7.</span> <span class="toc-text">进程阻塞原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">3.8.</span> <span class="toc-text">线程的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.9.</span> <span class="toc-text">线程与进程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">3.10.</span> <span class="toc-text">线程的组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E6%A6%82%E5%BF%B5"><span class="toc-number">3.11.</span> <span class="toc-text">处理机调度概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5"><span class="toc-number">3.12.</span> <span class="toc-text">处理机调度策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E5%87%86%E5%88%99"><span class="toc-number">3.13.</span> <span class="toc-text">处理机调度准则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E5%88%B6%E7%BA%A6%E5%85%B3%E7%B3%BB"><span class="toc-number">3.14.</span> <span class="toc-text">进程间的制约关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">3.15.</span> <span class="toc-text">进程同步的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">3.16.</span> <span class="toc-text">信号量的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">3.17.</span> <span class="toc-text">死锁的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E8%A7%A6%E5%8F%91%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.18.</span> <span class="toc-text">死锁触发的条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E7%AD%96%E7%95%A5"><span class="toc-number">3.19.</span> <span class="toc-text">解决死锁策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">设备管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%88%86%E7%B1%BB"><span class="toc-number">4.1.</span> <span class="toc-text">设备的概念与分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%8C%E6%88%90%E4%B8%80%E4%B8%AAIO%E8%AF%B7%E6%B1%82"><span class="toc-number">4.2.</span> <span class="toc-text">如何完成一个IO请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%9B%E8%A1%8C%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="toc-number">4.3.</span> <span class="toc-text">为什么进行设备管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="toc-number">4.4.</span> <span class="toc-text">如何进行设备管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">文件管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%87%E4%BB%B6"><span class="toc-number">5.1.</span> <span class="toc-text">什么是文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">5.2.</span> <span class="toc-text">文件的类型有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="toc-number">5.3.</span> <span class="toc-text">文件如何使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">5.4.</span> <span class="toc-text">文件的存储方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">5.5.</span> <span class="toc-text">文件管理是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-number">5.6.</span> <span class="toc-text">如何进行文件管理</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/12/%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0QWidget%EF%BC%88parent%EF%BC%89/" title="关于构造函数QWidget（parent）">关于构造函数QWidget（parent）</a><time datetime="2023-11-12T06:02:28.000Z" title="发表于 2023-11-12 14:02:28">2023-11-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/12/Qt%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%EF%BC%88File%EF%BC%89/" title="Qt文件相关（File）">Qt文件相关（File）</a><time datetime="2023-11-12T05:57:19.000Z" title="发表于 2023-11-12 13:57:19">2023-11-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/12/QThread%E7%94%A8%E6%B3%95/" title="QThread用法">QThread用法</a><time datetime="2023-11-12T05:50:18.000Z" title="发表于 2023-11-12 13:50:18">2023-11-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/05/QObject%E3%80%81Qt%E5%85%83%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F%E3%80%81%E5%AF%B9%E8%B1%A1%E6%A0%91%E3%80%81%E5%B1%9E%E6%80%A7%E7%B3%BB%E7%BB%9F/" title="QObject、Qt元对象系统、对象树、属性系统">QObject、Qt元对象系统、对象树、属性系统</a><time datetime="2023-11-05T14:32:03.000Z" title="发表于 2023-11-05 22:32:03">2023-11-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/05/const%E5%B0%8F%E7%BB%93/" title="const小结">const小结</a><time datetime="2023-11-04T23:50:23.000Z" title="发表于 2023-11-05 07:50:23">2023-11-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Martin</div><div class="footer_custom_text">Mr Huangの半岛铁盒</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !true) {
    if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><script>(() => {
  const disqus_config = function () {
    this.page.url = 'https://huang-pepsi.github.io/2023/09/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/'
    this.page.identifier = '/2023/09/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/'
    this.page.title = '操作系统学习小结'
  }

  const disqusReset = () => {
    window.DISQUS && window.DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  btf.addGlobalFn('themeChange', disqusReset, 'disqus')

  const loadDisqus = () =>{
    if (window.DISQUS) disqusReset()
    else {
      const script = document.createElement('script')
      script.src = 'https://.disqus.com/embed.js'
      script.setAttribute('data-timestamp', +new Date())
      document.head.appendChild(script)
    }
  }

  const getCount = async() => {
    try {
      const eleGroup = document.querySelector('#post-meta .disqus-comment-count')
      if (!eleGroup) return
      const cleanedLinks = eleGroup.href.replace(/#post-comment$/, '')

      const res = await fetch(`https://disqus.com/api/3.0/threads/set.json?forum=&api_key=&thread:link=${cleanedLinks}`,{
        method: 'GET'
      })
      const result = await res.json()

      const count = result.response.length ? result.response[0].posts : 0
      eleGroup.textContent = count
    } catch (err) {
      console.error(err)
    }
  }

  if ('Valine' === 'Disqus' || !true) {
    if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
    else {
      loadDisqus()
      GLOBAL_CONFIG_SITE.isPost && getCount()
    }
  } else {
    window.loadOtherComment = loadDisqus
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>