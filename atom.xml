<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Martin&#39;s Blog</title>
  
  <subtitle>个人博客</subtitle>
  <link href="https://huang-pepsi.github.io/atom.xml" rel="self"/>
  
  <link href="https://huang-pepsi.github.io/"/>
  <updated>2023-09-21T05:32:23.142Z</updated>
  <id>https://huang-pepsi.github.io/</id>
  
  <author>
    <name>Martin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机网络学习小结</title>
    <link href="https://huang-pepsi.github.io/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
    <id>https://huang-pepsi.github.io/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/</id>
    <published>2023-09-20T12:47:06.000Z</published>
    <updated>2023-09-21T05:32:23.142Z</updated>
    
    <content type="html"><![CDATA[<p>TCP&#x2F;IP五层网络自顶向下分别为应用层、传输层、网络层、数据链路层、物理层，也可分为四层（数据链路层与物理层合并为网络接口层）<br><img src="Pasted image 20230920210006.png" width=60%></p><p>各层用到的协议：<br><img src="Pasted image 20230920210606.png" width=60%></p><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h3 id="传输层提供两个主机进程间数据传输服务，主要有TCP和UDP两种协议"><a href="#传输层提供两个主机进程间数据传输服务，主要有TCP和UDP两种协议" class="headerlink" title="传输层提供两个主机进程间数据传输服务，主要有TCP和UDP两种协议"></a>传输层提供两个主机进程间数据传输服务，主要有TCP和UDP两种协议</h3><ol><li>   传输层提供的服务有：<br>  - 数据传输。<br>  - 错误检查。<br>  - 可靠数据传输。数据的正确性和有序性。<br>  - 拥塞控制。</li></ol><h3 id="传输层工作机制"><a href="#传输层工作机制" class="headerlink" title="传输层工作机制"></a>传输层工作机制</h3><ol><li>   发送数据的过程：<br>  - 客户端进程组装应用层报文<br>  - 进程根据传输层协议，创建相应的 Socket。<br>  - 进程将应用层消息传给 Socket。<br>  - Socket 将应用层报文（Message）分成多份，加上传输层报文头。封装成传输层报文段（Segment）传递给网络层。</li><li>   接收数据的过程：<br>  - 网络层将组装好的报文段传给传输层。<br>  - 传输层接收到报文段，根据报文段的头部信息中的目标端口，将报文段传给指定的 Socket。<br>  - Socket 收集到所有的报文段后，将报文段转换为应用层报文。<br>  - 进程读取 Socket 中的应用层报文。</li></ol><h3 id="UDP协议（User-Datagram-Protocol）"><a href="#UDP协议（User-Datagram-Protocol）" class="headerlink" title="UDP协议（User Datagram Protocol）"></a>UDP协议（User Datagram Protocol）</h3><ol><li>   UDP运用场景：  <img src="UDP运用场景.png" width=60%></li><li>   UDP报文段结构：  <img src="UDP报文段结构.png" width=60%>  相比TCP的首部20字节，UDP只有8字节</li><li>UDP和IP数据报的区别：</li></ol><pre><code>UDP计算检验和的方法和计算IP数据报首部检验和的方法相似。但不同的是：IP数据报的检验和只检验IP数据报的首部，但UDP的检验和是把首部和数据部分一起都检验。</code></pre><h3 id="TCP协议（Transmission-Control-Protocol）"><a href="#TCP协议（Transmission-Control-Protocol）" class="headerlink" title="TCP协议（Transmission Control Protocol）"></a>TCP协议（Transmission Control Protocol）</h3><ol><li>   TCP 协议有以下特点：<br>  - 可靠的数据传输<br>  - 面向连接</li><li>   TCP报文段结构：  <img src="TCP报文段结构.png" width=60%></li><li>   TCP的连接机制（三次握手）：<br>  第一次握手（SYN）：<br>      - 客户端向服务器发送一个TCP数据包，其中包含了一个SYN（同步）标志位和一个随机生成的初始序列号（ISN）。这表明客户端希望建立连接。<br>  第二次握手（SYN-ACK）：<br>      - 服务器收到客户端的SYN请求后，如果同意建立连接，会回应一个TCP数据包，其中包含SYN和ACK（确认）标志位。服务器也会生成一个随机的初始序列号，并将客户端的初始序列号加一，作为确认号。这表明服务器愿意建立连接，并且确认了客户端的请求。<br>  第三次握手（ACK）：<br>      - 客户端接收到服务器的响应后，会发送一个包含ACK标志位的TCP数据包，表示对服务器的确认。客户端的序列号也会加一，并且确认号设置为服务器的初始序列号加一。这样，双方的连接就建立起来了。</li><li>   TCP断开连接机制（四次挥手）：<br>  第一次挥手（FIN，客户端发送）：<br>      - 客户端向服务器发送一个TCP数据包，其中包含FIN（结束）标志位，表示客户端不再发送数据，但仍然愿意接收数据。客户端希望关闭输出流，但保持输入流打开，以确保服务器仍可以向客户端发送数据。<br> 第二次挥手（ACK，服务器发送）：<br>      - 服务器接收到客户端的FIN后，会发送一个TCP数据包，其中包含一个ACK标志位，以确认收到客户端的关闭请求。此时，服务器仍然可以向客户端发送数据。<br> 第三次挥手（FIN，服务器发送）：<br>      - 当服务器准备好关闭输出流时，它会向客户端发送一个TCP数据包，其中包含FIN标志位，表示服务器不再发送数据。这个步骤通知客户端服务器已经完成了数据传输。<br> 第四次挥手（ACK，客户端发送）：<br>      - 客户端接收到服务器的FIN后，会发送一个TCP数据包，其中包含ACK标志位，以确认收到服务器的关闭请求。此时，客户端和服务器都完成了关闭操作，连接被完全关闭。</li><li>   挥手会出现的问题：</li><li>   可靠数据传输的条件：<br>      - 无数据缺失<br>      - 无数据错误<br>      - 无数据重复<br>      - 数据传输顺序正确</li><li>   TCP如何控制流量：<br>      TCP流控制是一种用于调整TCP连接中数据的传输速率的机制，以确保发送方不会过快地向接收方发送数据，从而防止网络拥塞和数据丢失。TCP流控制使用滑动窗口机制来实现，该窗口大小根据接收方的能力来动态调整。<br>      - 滑动窗口机制<br>          TCP连接的每一端都会维护一个接收窗口（Receive Window）的大小。这个窗口表示了接收方可以接受的未确认数据的最大数量。发送方必须确保发送的数据不会超过接收窗口的大小。<br>      - 接收方通知滑动窗口的大小<br>          接收方会周期性地通告其当前接收窗口的大小给发送方。这个信息包含在TCP报文的窗口字段中。接收方可以根据其可用的缓冲区空间来调整窗口大小。<br>      - 发送方控制发送速率<br>          发送方根据接收方通告的窗口大小来控制发送速率。发送方会发送数据，但不会发送超过窗口大小的数据量。如果窗口变小，发送方会减慢发送速率以避免发送过多数据。<br>      - 动态调整窗口大小<br>          接收方可以根据其缓冲区的可用空间来动态调整窗口大小。如果接收方的缓冲区充足，窗口可以增大，允许更多数据的传输。如果缓冲区即将满了，窗口可以减小，以避免数据的溢出和丢失。</li><li>   拥塞控制：<br>      拥塞控制是TCP协议中的一项关键机制，用于监测网络中的拥塞情况并采取措施来避免或减轻拥塞。拥塞控制的主要目标是防止过多的数据包在网络中造成丢失，从而维持网络的稳定性和性能。</li></ol><h1 id="网络层-Network-Layer"><a href="#网络层-Network-Layer" class="headerlink" title="网络层(Network Layer)"></a>网络层(Network Layer)</h1><h3 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h3><ol><li>   IP：IP地址就是给因特网上的每一个主机（或路由器）的每一个接口（网卡）分配一个在全世界范围内唯一的32位的标识符。IP地址并不仅仅指明一个主机，而是还指明了主机所连接到的网络。</li><li>   IP数据报格式：<img src="IP数据报格式.png" width=60%></li><li>   网络层包含的协议：<br>  - IP协议（Internet Protocol，因特网互联协议）;<br>  - ICMP协议（Internet Control Message Protocol，因特网控制报文协议）;<br>  - ARP协议（Address Resolution Protocol，地址解析协议）;<br>  - RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）。</li><li>   路由原理：主机将IP数据报发送给路由器，路由器计算选择下一个能到达目标主机的路由器。若无法计算出下一个路由器，则发送给缺省网关进行查询发送。</li></ol><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;TCP&amp;#x2F;IP五层网络自顶向下分别为应用层、传输层、网络层、数据链路层、物理层，也可分为四层（数据链路层与物理层合并为网络接口层）&lt;br&gt;&lt;img src=&quot;Pasted image 20230920210006.png&quot; width=60%&gt;&lt;/p&gt;
&lt;p&gt;各层用</summary>
      
    
    
    
    
    <category term="网络" scheme="https://huang-pepsi.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>编码知识小结</title>
    <link href="https://huang-pepsi.github.io/2023/09/20/%E7%BC%96%E7%A0%81%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/%E7%BC%96%E7%A0%81%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    <id>https://huang-pepsi.github.io/2023/09/20/%E7%BC%96%E7%A0%81%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/%E7%BC%96%E7%A0%81%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</id>
    <published>2023-09-20T12:35:35.000Z</published>
    <updated>2023-09-20T12:38:42.303Z</updated>
    
    <content type="html"><![CDATA[<p>开始计算机由美国人发明，只需要输入简单的符号和英文字母就可以。一个字节可以表示256个符号，于是就创造了<strong>ASCII编码</strong>。ASCII编码大小1字节，第一位为0，所以有7位表示字符，也就是一共表示128个字符。</p><p>后来随着计算机的发展，欧洲、亚洲地区不同语言需要不同的字符表示，在原有的ASCII编码基础需要有扩展。各国有自己的编码标准，如中国制定了<strong>GB2312</strong>编码，日本把日文编到<strong>Shift_JIS</strong>里，韩国把韩文编到<strong>Euc-kr</strong>里。</p><p>这样就导致了编码标准的冲突，所以需要有统一的编码标准。于是<strong>Unicode字符集</strong>应运而生，Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。</p><p>Unicode字符集可用1~4字节表示一个字符，<strong>通常是两个字节</strong>。Unicode编码方案有很多，常见的Unicode编码方案包括UTF-8、UTF-16、UTF-32等。</p><p>以UTF-8为例，UTF-8是以一个字节为单位对Unicode进行编码。UTF-8（8-bit Unicode Transformation Format）是一种针对Unicode的可变长度字符编码，又称万国码，由Ken Thompson于1992年创建。需要注意的是，UTF-8是<strong>可变长度</strong>的字符编码，UTF-8用1-4个字节编码Unicode字符，是一种不定长的编码方案。UTF-8 是一个非常惊艳的编码方式，漂亮的实现了对 ASCII 码的<strong>向后兼容</strong>，以保证 Unicode 可以被大众接受。UTF-8 是目前互联网上使用最广泛的一种 Unicode 编码方式，它的最大特点就是可变长。它可以使用 1 - 4 个字节表示一个字符，根据字符的不同变换长度。总结起来，Unicode是一个字符集，定义了每个字符的唯一标识符（码点），而UTF-8是一种字符编码方式，用于将这些码点映射到字节序列以便在计算机上存储和传输。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;开始计算机由美国人发明，只需要输入简单的符号和英文字母就可以。一个字节可以表示256个符号，于是就创造了&lt;strong&gt;ASCII编码&lt;/strong&gt;。ASCII编码大小1字节，第一位为0，所以有7位表示字符，也就是一共表示128个字符。&lt;/p&gt;
&lt;p&gt;后来随着计算机的发</summary>
      
    
    
    
    
    <category term="编码" scheme="https://huang-pepsi.github.io/tags/%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>C++多态</title>
    <link href="https://huang-pepsi.github.io/2023/09/19/C++%E5%A4%9A%E6%80%81/"/>
    <id>https://huang-pepsi.github.io/2023/09/19/C++%E5%A4%9A%E6%80%81/</id>
    <published>2023-09-19T14:39:32.000Z</published>
    <updated>2023-09-19T14:50:57.291Z</updated>
    
    <content type="html"><![CDATA[<p>1.在成员函数内可以调用纯虚函数，在构造函数&#x2F;析构函数内部不能使用纯虚函数。</p><p>如果一个类从抽象类派生而来，它必须实现了基类中的所有纯虚函数，才能成为非抽象类。</p><p>2.基类的析构函数为虚函数时<br><img src="1.png" width=65%></p><p>3.虚函数理解：实现多态性，定义父类指针指向子类对象，调用指针时访问的是子类的重载函数。<br><img src="Pasted image 20230919094318.png" width=65% div=11></p><p>4.字节对齐+static不影响类大小+虚指针大小为8<br><img src="Pasted image 20230919095114.png" width=65%><br>5.对于含有虚函数的类，不管有多少个虚函数，只有一个虚指针</p><p>6.Virtual关键字其实质是告知编译系统，被指定为virtual的函数采用动态联编的形式编译。</p><p>函数名联编：将源代码中的函数调用解释为执行特定的函数代码块的过程称为函数名联编。<br>同一个名称的函数有多种，联编就是把调用和具体的实现进行链接映射的操作。</p><p>静态联编：编译阶段就已经知道操作与相应操作的执行之间的关系</p><p>动态联编：运行阶段才知道具体操作与相应执行代码块之间的关系</p><p>例：<br><img src="Pasted image 20230919102214.png" width=65%><br>此时，编译阶段已确定talk为person类的方法</p><p>理论上编译器当然是可判断的，因为编译器本就能看到所有的代码。</p><p>***但编译器的本质任务是代码的转换，它不会从主函数的第一行执行到最后一行来看每个指针实际指向对象的类型，因为这不是编译期要做的任务</p><p>***即使你自己实现了含有这个功能的编译器，那同样也是编译期不清楚类型。因为这是你的编译器的运行期做的检测，而不是编译期做的检测。编译期当然不清楚</p><p>对于动态联编的理解：对于虚函数，编译器只在运行时判断父类指针指向的子类类型，这是一个标准。</p><p>7.为什么要有纯虚函数？<br>**基类实例化对象不合理<br>派生类需要实现函数</p><p>8.首先，<strong>每个使用虚函数的类（或者从使用虚函数的类派生）都有自己的虚拟表</strong>。该表只是编译器在编译时设置的静态数组。虚拟表包含可由类的对象调用的每个虚函数的一个条目。此表中的每个条目只是一个函数指针，指向该类可访问的派生函数。<br><img src="Pasted image 20230919092704.png" width=65%></p><p>9.给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向存放函数地址的数组的指针。这种数组称为虚函数表(virtual function table, vtbl)。虚函数表中存储了为类对象进行声明的虚函数的地址。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.在成员函数内可以调用纯虚函数，在构造函数&amp;#x2F;析构函数内部不能使用纯虚函数。&lt;/p&gt;
&lt;p&gt;如果一个类从抽象类派生而来，它必须实现了基类中的所有纯虚函数，才能成为非抽象类。&lt;/p&gt;
&lt;p&gt;2.基类的析构函数为虚函数时&lt;br&gt;&lt;img src=&quot;1.png&quot; wid</summary>
      
    
    
    
    
    <category term="C++" scheme="https://huang-pepsi.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>QTitan中MVC小结</title>
    <link href="https://huang-pepsi.github.io/2023/09/18/Blog/QTitan%E4%B8%ADMVC%E5%B0%8F%E7%BB%93/"/>
    <id>https://huang-pepsi.github.io/2023/09/18/Blog/QTitan%E4%B8%ADMVC%E5%B0%8F%E7%BB%93/</id>
    <published>2023-09-18T13:40:55.000Z</published>
    <updated>2023-09-18T13:45:43.579Z</updated>
    
    <content type="html"><![CDATA[<p>研究了QTitan中的Grid例子，自己也写了自己的demo，写写对其中代码编写的理解。</p><h2 id="MVC是什么？"><a href="#MVC是什么？" class="headerlink" title="MVC是什么？"></a>MVC是什么？</h2><p>MVC是一种软件设计模式，用于组织和管理应用程序的代码。它代表Model-View-Controller（模型-视图-控制器）模式，是一种将应用程序分成三个主要组成部分的方法，每个部分都有不同的责任和任务。这种分层方法有助于提高应用程序的可维护性、可扩展性和可重用性。</p><p>简单来说，model相当于是一个在后台负责整理数据逻辑组织方式的一个进程，例如Tree的组织结构，model就为我们把Tree的结点内容、父子节点关系等等给串联起来。controller属于一个中转程序，它是model和view之间的一个桥梁，model有更新会通过controller处理，再通知view进行更新，之前不是很理解为什么要有这一层，因为直接model与view互动就行了呀，感觉这样太麻烦。当然，如果只是很简单的model&amp;view感觉直接传递好像也没什么，但是当model与view互动多了，就会出现很多的问题，例如view的异常操作、view或model要与其他的类进行关联等等，这时你会发现由于model与view之间的耦合度太高导致改动很繁琐。所以呢这也突出了controller的重要性—–解耦，通过这个中转机构model与view耦合度大大下降，对用户的操作也更加简单明了，这也突出了可维护性与可扩展性。view作为与用户直接打交道的界面，能实时显示用户需要的信息，也能接受系列GUI操作。如果你想在其他的view上显示该model的内容，直接调用相应的接口就可以实现，是不是很方便？</p><p><img src="https://picx.zhimg.com/80/v2-a9964761f3e2d74c5aa9147b35d20fa5_720w.png?source=d16d100b"></p><p>左图表示一个视图对应多个模型，表示用户在一个界面上查看不同模块的内容，例如打开某地图app，画面不仅有地图，还有天气等信息。右图表示一个模型对应多个视图，表示用户在多个界面查看同一模块的不同部分，例如火箭升空，地面操作人员在不同的区域查看火箭不同部分的实时信息。</p><h2 id="QTitan中MVC的使用小结"><a href="#QTitan中MVC的使用小结" class="headerlink" title="QTitan中MVC的使用小结"></a>QTitan中MVC的使用小结</h2><h3 id="搭建MVC框架流程"><a href="#搭建MVC框架流程" class="headerlink" title="搭建MVC框架流程"></a>搭建MVC框架流程</h3><p>QTitan中使用TreeGrid类创建一个widget作为view的载体，它可以进行一些layout操作。创建好了TreeGrid，通过调用它的setViewType(GridViewType type)就可以设置自己的view，这里将type设为TreeView，然后执行完这一行代码，QTitan为我们做了很多事（初始化），如创建自己的controller、options（视图相关的选项。关于GridViewOptions类，我通过调用它的setSelectionPolicy使View变成行单选模式，这个类控制view的一些行为。）等。</p><pre><code>m_Tree = new Qtitan::TreeGrid(this);//创建treeGridm_Tree-&gt;setViewType(Qtitan::TreeGrid::TreeView);//设置view类型，初始化viewm_View = m_Tree-&gt;view&lt;Qtitan::GridTreeView&gt;();//m_view为grid的view的指针</code></pre><p>创建好了view，此时调用view的setmodel函数关联自己的model，执行完该函数，view会通过自己的controller对自己原有的model解绑系列信号槽并绑定新的信号槽。</p><pre><code>const QStringList headers(&#123; tr(&quot;column1&quot;), tr(&quot;column2&quot;) &#125;);m_Model = new TreeModel(headers);//自定义treemodel，设置表头m_View-&gt;options().setSelectionPolicy(GridViewOptions::RowSelection);//设置行单选m_View-&gt;setModel(m_model);//绑定modelm_View-&gt;bestFit(Qtitan::FitToHeaderAndContent);//设置自适应数据调整表格大小</code></pre><p>到这里，一套MVC就算搭建完成了，后面可以设置具体的model内容与view风格了。</p><h3 id="关于TreeModel（继承QAbstractItemModel）"><a href="#关于TreeModel（继承QAbstractItemModel）" class="headerlink" title="关于TreeModel（继承QAbstractItemModel）"></a>关于TreeModel（继承QAbstractItemModel）</h3><p>QAbstractItemModel是一个数据模型的基类，它定义了数据的组织和访问方式。它是一个抽象类，提供了一些接口与信号槽，通过继承它去实现自己需要的一些功能，这里的TreeModel就是继承QAbstractItemModel实现基本接口并扩展了部分功能。</p><p>Model的分类：</p><p>model有list model、table model与tree model三种类型，list model适合显示具有列表结构的数据集，table model适合显示表格结构的数据集，tree model适合显示树状结构的数据集。其中list model与table model可以看作是特殊的tree model。</p><p><img src="https://picx.zhimg.com/80/v2-49b8b67df194bd1e8a12a2c7d7fe8ec7_720w.png?source=d16d100b"></p><p>QModelIndex类：</p><p>可以看出，若要找到model中某个cell或者item，则需要索引查找，那么就有了QModelIndex，这个索引类提供了行和列的数据，它还在内部定义了一个指针，指向它所属的模型对象，对于list model和table model可以通过行列用来定位item或者cell。但是对于tree model，只知道行列的信息还不能进行定位，此时还需要传递它的父节点的索引。这样，每个最小的单元就会对应一个ModelIndex。Model就可以根据ModelIndex来显示或者设置数据了。</p><p>TreeItem类：</p><p>Model的每一行可以看作一个item，对于每一个item，可以自定义TreeItem类，例如Qt里的QTreeWidgetItem类就是自定义的单独类，item存放自己的数据以及父子节点关系。</p><p>需注意的是初始化TreeModel时在其构造函数是需要创造自己的rootItem的，该item存放model的表头信息，QTitan通过系列调用最后识别这个rootitem的表头信息创建表头。</p><h3 id="关于TreeView（继承自ViewBase）"><a href="#关于TreeView（继承自ViewBase）" class="headerlink" title="关于TreeView（继承自ViewBase）"></a>关于TreeView（继承自ViewBase）</h3><p>View类创造出直接与用户交互的界面，它负责设计界面的框架（如Panel、Filter、Chooser、Menu、Zoom、stroller等）、接受用户的系列操作（单击、双击、拖动、选择多行）等功能，不负责每个数据项的绘制。</p><p>与它相关的类有ViewOptions、ColumnBase等。ViewOptions类用于设置界面的风格、状态等，例如行的多选与单选、界面是否可放大等，它继承自ViewOptionsAbstract，该类绑定自己的View。ColumnBase类用于设置列的系列参数和状态，如表头信息、是否可拖动、大小等，该类绑定自己的View。</p><pre><code>     Qtitan::GridTableColumn* column = (Qtitan::GridTableColumn *)View-&gt;getColumnByModelColumnName(tr(&quot;索引&quot;));//可通过列名得到列的指针     m_View-&gt;tableOptions().setRowsQuickSelection(true);//设置checkbox     m_View-&gt;options().setSelectionPolicy(GridViewOptions::MultiRowSelection);//设置行多选</code></pre><h3 id="关于ModelController"><a href="#关于ModelController" class="headerlink" title="关于ModelController"></a>关于ModelController</h3><p>Controller作为中间层扮演着很重要的的角色。它的职能有很多，包括对view的系列操作的识别和传递信息，对于model的变化的信息传递，对于异常和错误的处理，若没有这个中间层则可能导致model与view交互的众多问题。</p><p>ModelController类主要控制着与model交互的信息，如行列的增删、焦点设置、数据的排列方式等，View类里很多的操作函数底层都是运用相应的Controller进行操作。相关联的类有GridModelDataBinding、GridSelection、GridFilter、GridPersistentRow等。</p><p>GridModelDataBinding类</p><p>此类维护一个列的数据（列号、列名、Role），唯一绑定一个控制器，也可设置数据，但还是用其控制器执行操作。控制器里用一个QVector容器存放所有列的信息。</p><p>GridFilter类</p><p>此类可执行信息的验证、过滤信息等操作，唯一绑定一个控制器， 控制器类里有m_filter，m_relationFilter，m_findFilter这几个私有成员变量。</p><p>GridSummary类</p><p>用于统计列的数据，平均值、和、最大最小值等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;研究了QTitan中的Grid例子，自己也写了自己的demo，写写对其中代码编写的理解。&lt;/p&gt;
&lt;h2 id=&quot;MVC是什么？&quot;&gt;&lt;a href=&quot;#MVC是什么？&quot; class=&quot;headerlink&quot; title=&quot;MVC是什么？&quot;&gt;&lt;/a&gt;MVC是什么？&lt;/h2&gt;&lt;</summary>
      
    
    
    
    
    <category term="Qt" scheme="https://huang-pepsi.github.io/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Qt的Pro文件小结</title>
    <link href="https://huang-pepsi.github.io/2023/09/17/Blog/Qt%E7%9A%84Pro%E6%96%87%E4%BB%B6%E5%B0%8F%E7%BB%93/"/>
    <id>https://huang-pepsi.github.io/2023/09/17/Blog/Qt%E7%9A%84Pro%E6%96%87%E4%BB%B6%E5%B0%8F%E7%BB%93/</id>
    <published>2023-09-17T04:40:34.000Z</published>
    <updated>2023-09-20T01:29:36.470Z</updated>
    
    <content type="html"><![CDATA[<p>写一些Qt里pro文件相关知识，喜欢的小伙伴可以点点赞哦</p><p><img src="https://picx.zhimg.com/80/v2-aefbe0e7961fbcd68111cd7aad79d013_720w.png?source=d16d100b"></p><p>QT +&#x3D; 表示项目使用的模块，gui表示使用Qt的GUI部分功能，network表示使用Qt的网络部分功能</p><p>greaterThan(QT_MAJOR_VERSION, 4): QT +&#x3D; widgets 表示若目前Qt版本大于4，则增加widgets模块</p><h2 id="CONFIG关键字"><a href="#CONFIG关键字" class="headerlink" title="CONFIG关键字"></a>CONFIG关键字</h2><p>CONFIG +&#x3D; c++17表示该项目将使用 C++17 标准进行编译。</p><p>CONFIG +&#x3D; debug或release或release_and_debug表示指定编译配置是Debug模式还是Release模式。</p><p>CONFIG +&#x3D; console表示项目是一个控制台应用程序</p><p>CONFIG +&#x3D;shared或static表示指定生成动态链接库（shared）还是静态链接库（static）</p><h2 id="向项目中添加文件"><a href="#向项目中添加文件" class="headerlink" title="向项目中添加文件"></a>向项目中添加文件</h2><p>SOURCES +&#x3D; 、HEADERS +&#x3D; 、FORMS +&#x3D; 分别表示包含的源文件、头文件、ui文件（注意\表示换行）</p><p>TARGET&#x3D;ssqqss 表示设置生成的应用程序文件名</p><h2 id="目标安装路径INSTALLS"><a href="#目标安装路径INSTALLS" class="headerlink" title="目标安装路径INSTALLS"></a>目标安装路径INSTALLS</h2><p>qnx: target.path &#x3D; &#x2F;tmp&#x2F;$${TARGET}&#x2F;bin: 这一行意味着如果当前目标平台是 QNX（一个实时操作系统），那么目标文件将会被安装到 &#x2F;tmp&#x2F;$${TARGET}&#x2F;bin 目录中。其中，$${TARGET} 会被替换为你在.pro文件中指定的目标名称。</p><p>else: unix:!android: target.path &#x3D; &#x2F;opt&#x2F;$${TARGET}&#x2F;bin: 如果目标平台不是 QNX（因为上面的条件中包括了qnx），并且是一个 Unix-like 系统但不是 Android，那么目标文件将会被安装到 &#x2F;opt&#x2F;$${TARGET}&#x2F;bin 目录中。</p><p>!isEmpty(target.path): INSTALLS +&#x3D; target: 这行的作用是检查 target.path 是否被设置，如果已经设置，就将目标文件添加到安装列表中。也就是说，只有当前目标路径 target.path 不为空时，才会将目标文件添加到安装列表中。</p><p>总的来说，这些行的作用是根据当前的构建平台设置了不同的目标安装路径。在不同平台上，可能会有不同的目录结构和标准，因此可以使用条件语句来根据需要进行设置。</p><h2 id="TEMPLATE关键字"><a href="#TEMPLATE关键字" class="headerlink" title="TEMPLATE关键字"></a>TEMPLATE关键字</h2><p>TEMPLATE 是一个关键字，用于指定项目的类型。它决定了项目将会生成一个应用程序（可执行文件）还是一个库文件（动态链接库或静态库）。</p><p>TEMPLATE &#x3D; lib表示这个项目将会生成一个库文件（动态链接库或静态库），而不是一个可执行文件。</p><p>TEMPLATE &#x3D; app表示项目是一个应用程序项目，将会生成一个可执行文件。</p><p>TEMPLATE &#x3D; subdirs表示项目是一个子项目集合，可以包含多个子项目，每个子项目可以是一个应用程序项目或者库项目。</p><p>TEMPLATE &#x3D; app_bundle表示项目是一个 macOS 应用程序项目，将会生成一个 macOS 应用程序 bundle。</p><h2 id="LIBS关键字"><a href="#LIBS关键字" class="headerlink" title="LIBS关键字"></a>LIBS关键字</h2><p>LIBS +&#x3D; -lsystem_library表示链接系统库</p><p>LIBS +&#x3D; -L&#x2F;path&#x2F;to&#x2F;library -lmylibrary表示链接静态或动态库</p><h2 id="DESTDIR关键字"><a href="#DESTDIR关键字" class="headerlink" title="DESTDIR关键字"></a>DESTDIR关键字</h2><p>DESTDIR &#x3D; $$PWD&#x2F;..&#x2F;..&#x2F;..&#x2F;Bin表示指定编译输出文件的目标目录。通常，DESTDIR 用于指定编译后生成的可执行文件、库文件等的输出路径。</p><ul><li><p>如果没有指定 DESTDIR，默认情况下，Qt 会将编译生成的文件放在项目所在目录的一个子目录中，例如 debug 或者 release。</p></li><li><p>DESTDIR 可以是一个相对路径或者绝对路径。</p></li><li><p>DESTDIR 只影响编译后生成的文件的存放位置，不会影响程序的运行时行为。</p></li></ul><h2 id="INCLUDEPATH-DEPENDPATH关键字"><a href="#INCLUDEPATH-DEPENDPATH关键字" class="headerlink" title="INCLUDEPATH&#x2F;DEPENDPATH关键字"></a>INCLUDEPATH&#x2F;DEPENDPATH关键字</h2><p>INCLUDEPATH 是一个关键字，用于指定头文件的搜索路径。</p><p>DEPENDPATH 用于指定依赖关系的搜索路径。</p><p>INCLUDEPATH 用于编译器，以确保正确包含头文件，而 DEPENDPATH 用于构建系统，以确保正确查找项目的依赖关系。在许多情况下，你需要同时使用它们，以确保构建和编译都能够顺利进行。</p><h2 id="DEFINES-关键字"><a href="#DEFINES-关键字" class="headerlink" title="DEFINES 关键字"></a>DEFINES 关键字</h2><p>DEFINES 是一个关键字，用于指定预处理器宏的定义。</p><p>CONFIG(release, debug|release): DEFINES +&#x3D; RELEASE_STATUS表示如果项目处于 release 模式下，则会定义一个名为 RELEASE_STATUS 的宏。通过使用 DEFINES，你可以在编译过程中通过预处理器来控制代码的行为，从而使得在不同情况下能够灵活地配置和定制你的项目。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写一些Qt里pro文件相关知识，喜欢的小伙伴可以点点赞哦&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://picx.zhimg.com/80/v2-aefbe0e7961fbcd68111cd7aad79d013_720w.png?source=d16d100b&quot;&gt;&lt;/p</summary>
      
    
    
    
    
    <category term="Qt" scheme="https://huang-pepsi.github.io/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>操作系统学习小结</title>
    <link href="https://huang-pepsi.github.io/2023/09/17/Blog/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
    <id>https://huang-pepsi.github.io/2023/09/17/Blog/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/</id>
    <published>2023-09-17T04:30:06.000Z</published>
    <updated>2023-09-17T04:35:27.922Z</updated>
    
    <content type="html"><![CDATA[<p>想写一写操作系统的学习小结，将自己学习的思路与想法记录下来，目标是想以尽量通俗易懂的语言将一些抽象性的概念描述出来，在记录过程中会有一些不足之处，希望大家批评指正！共勉！</p><h2 id="操作系统的启动流程"><a href="#操作系统的启动流程" class="headerlink" title="操作系统的启动流程"></a>操作系统的启动流程</h2><h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><p>BIOS：BIOS为基本输入&#x2F;输出系统的简称，是计算机系统中的一种固件，它位于计算机的主板上，通常存储在一块可擦写的芯片中。BIOS是计算机启动时的关键组件之一，它负责初始化和检测硬件设备，启动操作系统，并提供一些基本的输入&#x2F;输出功能，如键盘、显示器和磁盘驱动器的控制。</p><p>bootloader：bootloader(引导加载程序)是一段特殊的程序，位于计算机硬盘或其他启动设备的特定区域，负责启动操作系统的加载过程。</p><h3 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h3><p>计算机开机后首先执行计算机主板上固化在芯片中的BIOS程序。</p><p>启动后，BIOS写入内存固定地址，CPU从内存起始位置开始执行命令</p><p>BIOS开始执行自检，将bootloader从DISK读入内存并开始执行</p><p><img src="https://picx.zhimg.com/80/v2-0f3de4c90030e15140047b96d0b33671_720w.png?source=d16d100b"></p><p>bootloader将操作系统从DISK加载到内存中并开始执行</p><p><img src="https://picx.zhimg.com/80/v2-adaa3ebebefd04cd1366e13e904de8d4_720w.png?source=d16d100b"></p><p>（注：BIOS存放位置：BIOS是存放在主板的一块ROM芯片上，操作系统与bootloader存放在DISK中）</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="一些概念-1"><a href="#一些概念-1" class="headerlink" title="一些概念"></a>一些概念</h3><p>内存碎片：</p><p>1.内碎片：分配单元内未使用的内存，如进程需要100K的空间，但系统分配给进程128KB的地址空间，就会在空间内部产生28K的未使用部分，称之为内部碎片</p><p>2.外碎片：分配单元间未使用的内存，例如进程与进程间未被使用的空间</p><p>减少内存碎片两种简单方法：</p><p>1.压缩式：将内存中的进程向上压缩，更紧致，腾出更大空闲块。此方法内存能有效利用但开销大</p><p>2.交换式碎片整理：将暂时不需要运行的进程放入磁盘，此方法磁盘与内存的交互会变频繁</p><p>内存连续分配的几个原则：</p><p>1.第一匹配原则：找到内存中第一个空闲的内存块满足需求，此原则操作简单，但易于产生大空闲块，外碎片多</p><p>2.最佳匹配原则：找到内存中与所需分配内存差别最小的空闲块，此原则重分配慢，会很多小的外碎片</p><p>3.最差匹配原则：将最大的空闲块分配给新进程，此原则尽可能地减少碎片，但可能产生很多小的碎片</p><p>上述做法都是在内存找到连续的内存块来分配新的进程，那么当内存中没有足够的内存块来分配新进程怎么办呢？引入了分页和分段机制。</p><h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><p>1.什么是段：计算机进程由多个模块组成，有代码段、数据段、堆栈段、附加段等（共享库段、只读段）等，这些段就是分段需要处理的段，每个段都有自己的基址和界限信息，用于指定段在内存中的位置和大小，每个段也都有自己的标识符，通常是一个整数或字符串。</p><p>2.什么是段表：段表即映射逻辑地址空间的段号与实际物理地址空间的段号的映射表。通常以数组或其他数据结构的形式存在。</p><p>3.段表如何将逻辑地址转化为物理地址：实际上，逻辑地址转换可能涉及更多的步骤和复杂性，如权限检查、异常处理等，但基本的原理是查找段表中的表项，通过一定的计算方法计算出表项的物理地址，然后执行必要的操作。</p><p><img src="https://picx.zhimg.com/80/v2-9d3d898189fc1273b9e29d4679495f47_720w.png?source=d16d100b"></p><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>1.什么是页：操作系统将进程的逻辑地址空间划分成相等大小的地址空间，每个地址空间称为页，同时将物理内存划分成相同大小的页框（Page Frame）。</p><p>2.什么是页表：操作系统维护一个称为页表（Page Table）的数据结构，用于跟踪每个进程的页与物理内存中的页框之间的映射关系。页表的条目存储了逻辑页号与物理页框号之间的映射关系。</p><p>3.页的大小：分页系统中，页的大小通常是固定的，典型的页大小为4KB或更大。这个大小取决于硬件和操作系统的设计。</p><p>4.分页优势：</p><p>内存管理的简化： 分页可以简化内存管理，因为页的大小是固定的，操作系统无需处理不同大小的内存块。</p><p>虚拟内存支持： 分页为虚拟内存提供了基础，因为虚拟内存可以很大，使得程序可以访问超出物理内存容量的数据，而这些数据可以被交换到磁盘上。</p><p>隔离和保护： 分页允许操作系统为每个进程创建独立的页表，从而实现了内存隔离和进程间的保护。</p><p>高效的内存利用： 分页允许操作系统更有效地利用物理内存，因为它可以将物理页框动态地分配给不同的进程，以满足它们的需求。</p><p>5.分页与分段的优缺点比较：</p><p><img src="https://picx.zhimg.com/80/v2-bd9a4193d51893a117f17fe1ee3f7da5_720w.png?source=d16d100b"></p><p>添加图片注释，不超过 140 字（可选）</p><p>6.进程的页表：每个进程都有自己的页表，当进程访问虚拟地址时，操作系统通过访问页表映射到物理地址，将数据加载到正确的位置。</p><ol><li><p>一个进程对应一张页表</p></li><li><p>进程的每一页对应一个页表项</p></li><li><p>每个页表项由页号和块号组成</p></li><li><p>页表记录进程页面和实际存放的内存块之间的对应关系</p></li><li><p>每个页表项的长度是相同的</p></li></ol><p><img src="https://pica.zhimg.com/80/v2-0bb621b9fbcc5fc0dc6df23681d94521_720w.png?source=d16d100b"></p><p>页寻址机制</p><p>7.缺页：缺页（Page Fault）是指程序在访问虚拟内存中的某个页面时，发现该页面并未加载到物理内存中，需要将其从磁盘或其他外部存储器加载到物理内存中才能继续执行相应的指令或访问相应的数据。</p><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="进程是什么"><a href="#进程是什么" class="headerlink" title="进程是什么"></a>进程是什么</h3><p>正在运行中的程序称为进程，进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。</p><h3 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h3><p>1.程序代码：要执行的程序的代码。通常是二进制指令或机器码的形式。程序代码定义了进程的任务和功能。</p><p>2.数据：用于存储变量、数据结构等，可在进程的生命周期内被读取和修改，允许程序在运行时维护状态。</p><p>3.堆栈：用于管理函数调用和局部变量。堆栈是一种数据结构，用于跟踪函数的调用和返回，以及保存局部变量的状态。</p><p>4.程序计数器（PC）：程序计数器是一个寄存器，用于存储下一条要执行的指令的地址。在执行程序时，PC会不断更新，以指示下一个要执行的指令。</p><p>5.寄存器状态：进程还包含了CPU寄存器的状态。寄存器用于存储计算中间结果、标志位和其他与进程执行相关的信息。</p><p>6.打开文件描述符：进程可以打开文件或其他资源，每个打开的文件都会分配一个文件描述符，用于跟踪和管理对文件的访问。</p><p>7.进程标识符PID：每个进程有唯一的标识符。</p><p>8.进程状态： 进程可以处于不同的状态，如运行、就绪、阻塞等。进程状态是进程的一个重要属性，操作系统根据状态来调度进程的执行。</p><p>9.上下文信息： 当操作系统需要切换到另一个进程时，它必须保存当前进程的上下文信息，包括寄存器状态、程序计数器值等。这个信息被存储在操作系统的数据结构中，以便在以后重新加载。</p><p><img src="https://pic1.zhimg.com/80/v2-54240f91dc62eccecc532f415e4855b6_720w.png?source=d16d100b"></p><p>进程的上下文切换</p><p>10.进程控制块PCB：进程控制块是操作系统中用于管理进程的数据结构。它包含了进程的所有重要信息，包括进程的状态、上下文信息、PID、优先级等。</p><h3 id="进程创建时间"><a href="#进程创建时间" class="headerlink" title="进程创建时间"></a>进程创建时间</h3><p>1.系统初始化：操作系统本身也是一个进程，它在计算机启动时就会被创建。操作系统的启动过程涉及创建多个系统级别的进程，以便管理计算机的各个方面。</p><p>2.用户请求：用户启动一个应用程序，这是最常见的情况。</p><p>3.运行的进程执行创建进程的系统调用，即运行中的进程需要创建新的进程</p><h3 id="进程如何创建"><a href="#进程如何创建" class="headerlink" title="进程如何创建"></a>进程如何创建</h3><p><img src="https://pic1.zhimg.com/80/v2-1a7c94279d0fd192fc22fd7f29ff4dd9_720w.png?source=d16d100b"></p><p>内存创建流程</p><p>分配进程控制块PCB与进程标识符PID：OS为新进程分配一个PCB与唯一的PID，PCB 是用来存储和管理进程信息的数据结构。PID用于唯一标识系统中的每个进程。</p><p>分配地址空间：OS会为新进程分配一块内存空间，用于存储程序代码、数据、堆栈等信息。这通常是通过虚拟内存管理实现的。</p><p>初始化上下文：OS会为新进程初始化上下文信息，主要为内部寄存器信息。</p><p>置于就绪状态：OS会将新进程设置为就绪状态并加入就绪队列</p><p>这些步骤构成了进程的创建流程。需要注意的是，不同的操作系统和编程环境可能具有不同的细节和方式来创建进程，但上述步骤是通用的概括。进程的创建是操作系统中的一个复杂任务，操作系统必须有效地管理和维护进程的状态和资源，以实现多任务处理。</p><h3 id="进程的生命周期"><a href="#进程的生命周期" class="headerlink" title="进程的生命周期"></a>进程的生命周期</h3><p><img src="https://picx.zhimg.com/80/v2-593f3a733bae01b3f7cf7709ea223fb0_720w.png?source=d16d100b"></p><h3 id="进程间的通信"><a href="#进程间的通信" class="headerlink" title="进程间的通信"></a>进程间的通信</h3><p>进程通信是指在计算机系统中，不同的进程之间需要传递信息、共享数据或协同工作的一种机制。进程通信通常发生在多任务操作系统中，其中多个进程同时运行并可能需要协作完成任务。以下是一些常见的进程通信方式：</p><ol><li><p>管道（Pipe）：管道是一种单向通信机制，允许一个进程将数据写入管道，而另一个进程从同一管道读取数据。通常，一个进程充当写入者，而另一个充当读取者。</p></li><li><p>命名管道（Named Pipe）：与管道类似，但允许不同进程通过共享的命名管道进行通信，而不仅仅是父子进程之间。</p></li><li><p>消息队列（Message Queue）：消息队列允许进程通过发送消息进行通信。这些消息可以包含数据以及用于标识消息类型或目标进程的信息。</p></li><li><p>信号（Signal）：信号是一种用于通知进程发生某些事件的机制。例如，一个进程可以向另一个进程发送信号，通知它应该终止或重新启动。</p></li><li><p>共享内存（Shared Memory）：共享内存允许多个进程共享同一块物理内存区域。这使得数据可以直接从一个进程传递到另一个进程，而无需复制数据。</p></li><li><p>套接字（Socket）：套接字是一种网络通信的方式，但也可以用于本地进程之间的通信。通过套接字，进程可以在不同计算机上或同一计算机上的不同端口进行通信。</p></li><li><p>信号量（Semaphore）：信号量是一种用于控制对共享资源的访问的机制。进程可以使用信号量来协调对共享资源的访问，以防止竞争条件。</p></li><li><p>文件（File）：进程可以通过读写共享文件来进行通信。一个进程可以将数据写入文件，而另一个进程可以从同一文件读取数据。</p></li><li><p>远程过程调用（RPC）和进程间通信（IPC）：这些是高级通信机制，允许远程计算机上的进程相互调用函数或方法，并通过网络传递数据。</p></li></ol><p>选择哪种进程通信方式取决于应用程序的需求和设计，以及操作系统提供的支持。不同的通信方式有不同的复杂性和性能特性，开发人员需要谨慎选择以满足特定场景的需求。</p><h3 id="进程阻塞原因"><a href="#进程阻塞原因" class="headerlink" title="进程阻塞原因"></a>进程阻塞原因</h3><p>1.请求数据未到达</p><p>2.等待系统调用</p><p>3.启动某种操作，无法马上执行</p><h3 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h3><p>线程是进程（Process）内部的一条执行路径。线程是操作系统能够进行调度和执行的最小单位，它包含了在进程中执行的指令序列和相关的数据。每个进程可以包含一个或多个线程，这些线程可以并发执行，共享进程的资源和内存空间。</p><h3 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h3><p>进程是资源分配的基本单位，线程是CPU调度的基本单位</p><p>单独性：</p><p>进程是独立的执行单元，拥有自己的独立内存空间和资源。每个进程都有自己的代码、数据和堆栈。进程与进程间是一般是互相隔离的。</p><p>线程是进程内的子执行单元，多个线程属于同一个进程，共享进程的内存空间和资源。</p><p>切换开销：</p><p>由于进程有独立的内存空间，进程之间的切换开销较大，需要保存和恢复大量的上下文信息。</p><p>线程之间的切换开销较小，因为它们共享相同的内存空间，上下文切换通常只需要保存和恢复寄存器的值，线程上下文切换不需要改变地址空间（不需要切换当前的虚拟内存空间或使用的页表）。</p><p>通信和同步：</p><p>进程之间通信较为复杂，通常需要使用进程间通信（IPC）机制，如管道、消息队列、共享内存等，来实现数据交换。</p><p>线程之间通信更容易，可以直接读写共享内存，但也需要注意同步问题，以避免竞态条件和数据一致性问题</p><p>创建和销毁成本：</p><p>创建和销毁进程的成本较高，因为每个进程都需要分配独立的内存空间和资源。</p><p>创建和销毁线程的成本较低，因为它们共享进程的资源，只需要分配一些额外的栈空间即可</p><p>安全性：</p><p>由于进程拥有独立的内存空间，进程之间更加隔离，一个进程的崩溃通常不会影响其他进程。</p><p>线程共享相同的内存空间，一个线程的错误可能会影响整个进程，导致进程崩溃（缺陷）。</p><h3 id="线程的组成"><a href="#线程的组成" class="headerlink" title="线程的组成"></a>线程的组成</h3><p>线程是计算机程序执行的最小单位，它由多个组成部分组成，这些部分协同工作以执行线程的任务。以下是线程的主要组成部分：</p><ol><li><p>线程ID（Thread ID）：线程ID是唯一标识一个线程的数字或标识符。它允许操作系统和程序来区分不同的线程。</p></li><li><p>寄存器集合（Register Set）：每个线程都有自己的寄存器集合，包括通用寄存器、程序计数器（PC）等。寄存器用于存储线程执行时的临时数据和状态信息。</p></li><li><p>栈（Stack）： 每个线程都有自己的栈，用于存储函数调用和局部变量。栈是一个后进先出（LIFO）数据结构，用于跟踪函数的调用和返回。</p></li><li><p>线程局部存储（Thread-Local Storage，TLS）：线程局部存储是线程私有的内存区域，用于存储线程特定的数据，这些数据对于其他线程不可见。线程局部存储通常用于保存线程的状态信息或其他线程无法共享的数据。</p></li><li><p>线程控制块（Thread Control Block，TCB）：线程控制块是操作系统维护的数据结构，用于存储线程的状态信息和管理线程的执行。TCB 包含线程的状态、优先级、寄存器值、线程ID等信息。</p></li><li><p>线程优先级（Thread Priority）：线程通常具有优先级，用于确定线程在竞争CPU时间时的执行顺序。较高优先级的线程可能会在较低优先级的线程之前执行。</p></li><li><p>线程状态（Thread State）：线程可以处于不同的状态，如运行、就绪、阻塞等。线程状态用于描述线程当前的执行情况。</p></li><li><p>线程同步机制：线程可能需要进行同步操作以避免竞态条件和数据访问冲突。线程同步机制包括互斥锁、信号量、条件变量等，用于控制线程的访问和操作共享资源。</p></li></ol><p>这些组成部分协同工作，使线程能够执行任务并与其他线程共享数据和资源。线程的创建、调度、销毁和同步等操作都受线程的组成部分和线程控制块的管理。理解线程的组成部分有助于开发者编写多线程程序并有效地管理线程的行为。</p><h3 id="处理机调度概念"><a href="#处理机调度概念" class="headerlink" title="处理机调度概念"></a>处理机调度概念</h3><p>处理机调度是操作系统的核心功能之一，它负责决定在多个就绪状态的进程或线程之间分配CPU时间片，以实现公平共享CPU资源，提高系统的性能和响应速度。以下是处理机调度的一些关键概念和方法：</p><p>调度队列（Scheduling Queue）:调度队列通常指的是在计算机操作系统中用于管理和执行进程的一种数据结构。它是一个按照一定的策略来安排和分配CPU时间的队列。调度队列的目的是优化资源的利用，确保系统能够高效地运行多个任务。</p><p>优先级（Priority）：在操作系统中，优先级调度是一种调度算法，它根据任务的优先级来分配CPU时间。每个任务都被分配一个优先级值，通常是一个整数，数值越小表示优先级越高。当系统中有多个任务需要执行时，优先级高的任务将会先被执行。</p><p>抢占性（Preemption）：抢占性是指操作系统可以在一个进程或任务还未完成时，剥夺其正在使用的CPU资源，将CPU资源分配给具有更高优先级的另一个进程或任务的能力。</p><p>在抢占性调度中，操作系统会根据某些规则（如优先级或时间片）来决定是否暂停当前正在执行的任务，并将CPU资源分配给另一个任务。这使得高优先级任务能够及时响应并执行，而不会被低优先级任务长时间占用CPU。</p><p>多核调度、实时调度（Real-Time Scheduling）、调度策略（Scheduling Policies）、上下文切换（Context Switching）</p><h3 id="处理机调度策略"><a href="#处理机调度策略" class="headerlink" title="处理机调度策略"></a>处理机调度策略</h3><p>先来先服务调度（First-Come, First-Served，FCFS）：按照进程到达的顺序分配CPU时间片。FCFS通常用于处理任务或进程的顺序，其中任务按照它们到达系统或队列的顺序来执行，最先到达的任务首先被处理，直到完成或等待某种事件发生后才进行下一个任务。</p><p>优缺点：简单且公平，但可能导致长作业等待时间。</p><p>最短作业优先调度（Shortest Job First，SJF）：选择估计执行时间最短的进程或线程先执行。（非抢占式）若在进程A进行过程中到来进程B和C，则比较BC的运行时间长短，等待A一直运行到结束，选择执行时间最短的任务。（抢占式）系统可以在任何时刻中断当前执行的任务，如果有一个更短的任务到达就绪队列，系统会立即切换到该任务。这种方式需要动态地监测任务的执行时间，并在需要时进行切换。</p><p>优缺点：最小化平均等待时间，但需要准确的执行时间估计。</p><p>轮转调度（Round Robin，RR）：将CPU时间划分成固定大小的时间片，每个进程或线程执行一个时间片，然后排到队列的末尾。</p><p>优缺点：公平分配CPU时间，适用于时间共享系统，但可能导致上下文切换开销。</p><p>优先级调度（Priority Scheduling）：</p><p>为每个进程或线程分配一个优先级，高优先级的先执行。</p><p>优缺点：可以根据任务的重要性分配优先级，但可能导致低优先级任务饥饿。</p><p>多级反馈队列调度（Multilevel Feedback Queue，MLFQ）：</p><p>将进程分为多个队列，每个队列有不同的优先级，新进程进入最高优先级队列。</p><p>根据进程的行为和性能动态调整队列和优先级，适用于多样化的工作负载。</p><h3 id="处理机调度准则"><a href="#处理机调度准则" class="headerlink" title="处理机调度准则"></a>处理机调度准则</h3><p>处理机调度是操作系统中的一个重要任务，它决定了在多个进程之间如何分配处理机时间，以最大程度地提高系统的吞吐量、响应时间和效率。不同的调度算法和准则可以用来实现不同的性能目标，以下是一些常见的处理机调度准则：</p><ol><li><p>公平性（Fairness）：确保每个进程都能获得公平的处理机时间，以防止某个进程长时间占用处理机而导致其他进程无法运行。</p></li><li><p>优先级（Priority）：为每个进程分配一个优先级，高优先级的进程在竞争处理机时间时会被优先考虑。这可以用于确保关键任务得到及时处理。</p></li><li><p>短作业优先（Shortest Job First，SJF）：优先选择估计执行时间最短的进程，以最小化平均等待时间。这需要对进程的执行时间有良好的估计。</p></li><li><p>轮转（Round Robin）：按照固定时间片（时间片轮转）或时间片可变（多级反馈队列）的方式分配处理机时间，以确保每个进程都有机会运行。这种方法适用于多任务系统。</p></li><li><p>多级队列（Multilevel Queue）：将进程分为多个队列，每个队列具有不同的优先级，不同队列之间采用不同的调度算法。例如，高优先级队列可能采用SJF调度，而低优先级队列采用轮转调度。</p></li><li><p>最早截止时间优先（Earliest Deadline First，EDF）：为每个进程分配一个截止时间，选择下一个要执行的进程时优先考虑截止时间最早的进程，以确保实时任务按时完成。</p></li><li><p>响应时间（Response Time）：优先选择能够更快响应用户输入或事件的进程，以提高系统的交互性能。</p></li><li><p>负载均衡（Load Balancing）：在多处理器系统中，调度器可以尝试将进程分配到不同的处理器上，以确保系统资源充分利用。</p></li><li><p>静态调度和动态调度：静态调度是在编译或系统启动时确定进程的调度顺序，而动态调度是在运行时根据系统的状态和进程的特性进行调度决策。</p></li></ol><p>不同的应用场景和系统要求可能需要不同的调度准则和算法。操作系统的调度器通常会根据实际情况选择合适的调度策略来满足性能需求。</p><h3 id="进程间的制约关系"><a href="#进程间的制约关系" class="headerlink" title="进程间的制约关系"></a>进程间的制约关系</h3><p>在多进程或多线程的计算机程序中，进程之间可以存在不同的制约关系，这些关系可以影响进程的执行顺序、资源共享和数据一致性。以下是一些常见的进程间制约关系：</p><ul><li><p>竞争条件（Race Condition）：竞争条件发生在多个进程试图同时访问共享资源时，而没有适当的同步机制来保护这些资源。这可能导致不可预测的结果和数据不一致。</p></li><li><p>互斥（Mutual Exclusion）：互斥关系是指多个进程不能同时进入临界区（访问共享资源的关键部分）。通过互斥锁或信号量等同步机制，可以确保只有一个进程能够进入临界区，从而防止竞争条件。</p></li><li><p>有序执行（Ordering Constraint）：有时，程序需要确保一些操作按照特定的顺序执行。例如，一个进程可能需要等待另一个进程完成某个操作后才能执行。</p></li><li><p>死锁（Deadlock）：死锁是一种进程间制约关系，其中多个进程都在等待对方释放某个资源，从而导致所有进程都无法继续执行。解决死锁问题需要谨慎地设计同步机制和资源管理策略。</p></li><li><p>优先级（Priority）：某些情况下，进程的执行顺序受其优先级的影响。高优先级的进程可能会在低优先级的进程之前执行。</p></li><li><p>依赖关系（Dependency）：多个进程之间可能存在依赖关系，其中一个进程必须等待另一个进程完成某项任务才能继续执行。这通常涉及到任务的协同工作。</p></li><li><p>通信（Communication）：进程之间可能需要进行通信以共享信息或传递数据。通信可以通过消息传递、共享内存等方式实现，并可能受到同步和顺序的影响。</p></li><li><p>条件等待（Conditional Wait）：某些情况下，一个进程可能需要等待某个条件满足后才能继续执行。这通常涉及到条件变量和等待&#x2F;通知机制。</p></li><li><p>饥饿（Starvation）：饥饿是指一个或多个进程由于长时间无法获得所需的资源或执行时间而无法继续执行。这可能由于优先级不当或竞争资源导致。</p></li></ul><h3 id="进程同步的概念"><a href="#进程同步的概念" class="headerlink" title="进程同步的概念"></a>进程同步的概念</h3><p>进程同步用于协调多个并发执行的进程或线程之间的操作，以确保数据的一致性和正确性。在多任务和多进程的操作系统中，进程同步非常关键，因为多个进程可能同时访问共享资源，如内存、文件、设备等，如果没有适当的同步机制，就会导致竞态条件和数据不一致的问题。</p><p>进程同步的目标是避免竞态条件（Race Condition）、死锁（Deadlock）、饥饿（Starvation）和优先级反转（Priority Inversion）等问题，以确保多个进程能够协作并正确地访问共享资源。</p><h3 id="信号量的概念"><a href="#信号量的概念" class="headerlink" title="信号量的概念"></a>信号量的概念</h3><p>信号量（Semaphore）是一种用于多进程或多线程编程中的同步工具，它用于控制对共享资源的访问。信号量可以帮助解决多个进程或线程之间的竞争条件，确保对共享资源的访问是有序和同步的。</p><p>信号量的基本概念包括以下几个要点：</p><ul><li><p>计数器：信号量是一个整数计数器，通常初始化为非负整数。这个计数器用来表示可用资源的数量或者某种条件的状态。</p></li><li><p>原子操作：对信号量的操作必须是原子操作，即不会被中断的操作。这确保了多个进程或线程同时尝试修改信号量时不会导致竞态条件。</p></li><li><p>等待和释放：信号量提供两种基本操作：等待（wait）和释放（post）。</p></li><li><p>等待操作：当一个进程或线程希望访问某个共享资源时，它首先执行等待操作。如果信号量的计数器大于零，那么等待操作会减少计数器的值，并允许进程或线程继续执行。如果计数器为零，等待操作可能会阻塞（挂起）进程或线程，直到计数器变为大于零为止。</p></li><li><p>释放操作：当一个进程或线程完成对共享资源的访问后，它执行释放操作，这会增加信号量的计数器。这样，其他等待资源的进程或线程可以继续执行。</p></li><li><p>控制资源访问：通过适当调整信号量的初始值和执行等待&#x2F;释放操作的时机，可以实现对共享资源的访问控制。例如，可以用信号量来限制同时访问某个共享资源的进程或线程数量。</p></li></ul><h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h3><p>它发生在多个进程或线程之间，每个都在等待某个事件或资源，但这些事件或资源互相依赖，导致所有进程或线程都无法继续执行的情况。简而言之，死锁是一种互相等待的僵局，阻塞了程序的进一步执行。</p><h3 id="死锁触发的条件"><a href="#死锁触发的条件" class="headerlink" title="死锁触发的条件"></a>死锁触发的条件</h3><ul><li><p>互斥条件（Mutual Exclusion）：至少有一个资源是互斥的，即只能被一个进程或线程占用，其他进程或线程必须等待释放。</p></li><li><p>持有与等待条件（Hold and Wait）：进程或线程至少持有一个资源，并等待获取其他资源，这时候如果其他资源正好被其他进程或线程占用，就会发生死锁。</p></li><li><p>不可剥夺条件（No Preemption）：资源不能被强制剥夺，只能由持有它的进程或线程主动释放。</p></li><li><p>环路等待条件（Circular Wait）：存在一个等待链，每个进程或线程都在等待下一个进程或线程释放资源，形成一个环路等待情况。</p></li></ul><h3 id="解决死锁策略"><a href="#解决死锁策略" class="headerlink" title="解决死锁策略"></a>解决死锁策略</h3><ol><li><p>资源分配策略：设计合理的资源分配策略，确保不会出现持有与等待和环路等待条件。例如，一种常见的策略是要求进程在开始执行之前一次性获取所有需要的资源，以防止持有与等待。</p></li><li><p>资源预分配：在系统初始化或运行时，为每个进程分配所需的资源，而不是等待进程请求资源。这种方法可以避免持有与等待条件。</p></li><li><p>资源优先级：给资源分配优先级，确保资源会被高优先级的进程或线程剥夺，并重新分配给其他进程。</p></li><li><p>超时机制：为等待资源的进程或线程设置超时，如果超时，则放弃等待或采取其他措施。</p></li><li><p>死锁检测与恢复：定期检测系统中是否存在死锁，一旦检测到死锁，采取措施中断其中一个进程或线程，以解除死锁。</p></li><li><p>避免共享资源：尽量减少共享资源的使用，或者使用无锁数据结构和算法，以减少发生死锁的机会。</p></li></ol><h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><h3 id="设备的概念与分类"><a href="#设备的概念与分类" class="headerlink" title="设备的概念与分类"></a>设备的概念与分类</h3><p>“设备”泛指计算机系统中的各种外部设备，即主机以外的其他所有设备。外部设备品种繁多，功能各异，对它们管理的好坏，会直接影响到整个系统的效率。</p><p>按分配特性分：</p><p>独享设备：一次只能分配给一个进程使用，常见有打印机。</p><p>共享设备：可以由几个用户进程交替地对它进行信息的读或写操作，常见有磁盘。</p><p>虚拟设备：把独享设备“改造”成为可以共享的设备，但实际上这种共享设备是不存在的，常见有虚拟网卡、虚拟磁盘等。</p><p>按功能分：</p><p>字符设备：一种在操作系统中表示以字符为单位进行读写的设备。如键盘、鼠标、串口、打印机等，与块设备相比，字符设备不会缓冲数据，而是将数据直接传输给设备或者从设备获取数据。这使得字符设备更适合处理以字符为单位的输入和输出操作。</p><p>优缺点：不需要缓存、低延时、灵活性高。但效率低（可能需要频繁读取）、不适合大量数据传输、不支持随机访问。</p><p>块设备：一种在操作系统中表示以固定大小的块（通常为512字节）为单位进行读写的设备。如硬盘、SD卡、CD&#x2F;DVD驱动器等，块设备的特点是能够以相对较高的速率进行数据传输，因为它们以较大的数据块为单位进行操作，而不是单个字符。这使得块设备适用于需要大量数据传输的场景，比如文件系统的读写操作。</p><p>优缺点：能大量传输数据、支持随机访问、支持缓存。复杂度高、不能实时响应。</p><h3 id="如何完成一个IO请求"><a href="#如何完成一个IO请求" class="headerlink" title="如何完成一个IO请求"></a>如何完成一个IO请求</h3><p>一些概念：</p><p>1.设备管理器：是操作系统中的一个系统工具或应用程序，用于管理计算机硬件设备。</p><p>2.设备驱动程序：是一种软件程序，它允许操作系统与硬件设备进行通信和控制。设备驱动程序充当操作系统与硬件之间的中介，使得操作系统可以通过标准接口来访问和控制各种硬件设备，而无需了解硬件的具体细节。简单地说，设备驱动程序将硬件设备抽象化，隐藏硬件细节，向操作系统提供接口。设备驱动程序的编写需要对硬件的特性和操作系统的接口有深入的了解。</p><p>3.设备控制器：与CPU进行交互，处理各种传入传出信号的硬件，内部有不同种类的寄存器来进行设备发送数据，接收数据、开启或者关闭等。每个设备控制器都会有一个应用程序与之对应，设备控制器通过应用程序的接口通过中断与操作系统进行通信。设备控制器是硬件，而设备驱动程序是软件。</p><p>步骤分析：</p><p>用户在程序中使用系统提供的输入&#x2F;输出命令发出I&#x2F;O请求——&gt;输入&#x2F;输出管理程序接受这个请求——&gt;设备驱动程序来具体完成所要求的 I&#x2F;O操作——&gt;设备中断处理程序来处理这个请求</p><p>1.I&#x2F;O请求来自用户作业进程。比如在某个进程的程序中使用系统提供的I&#x2F;O命令形式为READ（input,buffer,n）,它表示要求通过输入设备input，读入n个数据到由buffer指明的内存缓冲区中。</p><p>2.输入&#x2F;输出管理程序一方面从用户程序那里接受I&#x2F;O请求，另一方面把I&#x2F;O请求交给设备驱动程序去具体完成，因此起到一个桥梁的作用。输入&#x2F;输出管理程序首先接受用户对设备的操作请求，并把发出请求的进程由原来的运行状态改变为阻塞状态。如果当前设备空闲，那么管理程序验证了 I&#x2F;O 请求的合法性（比如不能对输入设备发输出命令，不能对输出设备发输入命令等）后，就把这个设备分配给该用户进程使用，调用设备驱动程序，去完成具体的输入&#x2F;输出任务。在整个 I&#x2F;O 操作完成之后，管理程序控制由设备驱动程序返回到输入输出管理程序，把等待这个 I&#x2F;O 完成的进程从阻塞队列上摘下来，并把它的状态由阻塞变为就绪，到就绪队列排队，再次参与对CPU的竞争。因此，设备的输入&#x2F;输出管理程序由3块内容组成：接受用户的I&#x2F;O请求，组织管理输入&#x2F;输出的进行，以及输入&#x2F;输出的善后处理。</p><p>3.在从输入&#x2F;输出管理程序手中接过控制权后，设备驱动程序就读出设备状态，判定其完好可用后，就直接向设备发出 I&#x2F;O 硬指令。在多道程序系统中，设备驱动程序一旦启动了一个I&#x2F;O操作，就让出对CPU的控制权，以便在输入&#x2F;输出设备忙于进行I&#x2F;O操作时，CPU能脱身去做其他的事情，从而提高处理机的利用率。</p><p>4.在设备完成一次输入&#x2F;输出操作之后，是通过中断来告知 CPU 的。当 CPU 接到来自 I&#x2F;O设备的中断信号后，就去调用该设备的中断处理程序。</p><h3 id="为什么进行设备管理"><a href="#为什么进行设备管理" class="headerlink" title="为什么进行设备管理"></a>为什么进行设备管理</h3><ul><li><p>操作系统设备管理的目标之一，是提高外部设备的利用率。在多道程序设计环境下，外部设备的数量肯定少于用户进程数，竞争不可避免。因此在系统运作过程中，如何合理地分配外部设备，协调它们之间的关系，如何充分发挥外部设备之间、外部设备与CPU之间的并行工作能力，使系统中的各种设备尽可能地处于忙碌状态，显然是一个非常重要的问题。</p></li><li><p>操作系统设备管理的目标之二是为用户提供便利、统一的使用界面。“界面”是用户与设备进行交流的手段。计算机系统配备的外部设备类型多样，特性不一，操作各异。操作系统必须把各种外部设备的物理特性隐藏起来，把各种外部设备的操作方式隐藏起来，这样，用户使用时才会感到便利，才会感到统一。</p></li></ul><h3 id="如何进行设备管理"><a href="#如何进行设备管理" class="headerlink" title="如何进行设备管理"></a>如何进行设备管理</h3><p><img src="https://picx.zhimg.com/80/v2-fb659fd1af3421c29b6e1a6a77006043_720w.png?source=d16d100b"></p><p>DCB（设备控制块）</p><p>设备控制块作用：</p><ol><li><p>设备状态追踪：DCB 会记录设备的状态信息，比如设备是否处于空闲状态、是否正在执行某个操作等。</p></li><li><p>设备控制：DCB 可以包含控制设备的信息，比如控制设备开始读取或写入数据。</p></li><li><p>缓冲区管理：DCB 可能会包括一个或多个缓冲区，用于暂存数据。例如，当你向打印机发送数据时，通常会先将数据写入一个缓冲区，然后再由打印机逐步处理。</p></li><li><p>中断处理：DCB 可能会包含一些用于处理设备中断的信息，以便及时响应设备事件。</p></li><li><p>错误处理：DCB 可以记录设备操作过程中发生的错误信息，以便系统能够采取相应的措施，比如重新尝试、报告错误等。</p></li><li><p>设备标识：DCB 包括了用于唯一标识设备的信息，以便操作系统能够正确地识别和管理不同的设备。</p></li></ol><p>设备管理步骤：</p><p><img src="https://pic1.zhimg.com/80/v2-42b2b4bb25045cf37223d6065050bcb8_720w.png?source=d16d100b"></p><p>操作系统对字符设备进行管理步骤</p><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><p>文件管理可从两方面看—文件和文件的管理，也就引申出什么是文件，文件组织方式（结构），操作系统如何对文件进行管理、调度。</p><p>前面介绍的存储管理和处理机管理，它们涉及的管理对象都是计算机系统中的硬件资源，即中央处理机（CPU）和内存储器(Memory)。计算机系统中还有一类资源，即软件资源，对它们的管理，要由操作系统中的“文件管理”来完成。</p><p>内存中的数据在断电时会丢失，如何将数据持久地存储，引入了文件管理的概念。由于系统的内存有限且不能长期保存，故将文件存放在外存中，到需要时再调入内存使用，需要操作系统高效地进行文件管理。</p><h3 id="什么是文件"><a href="#什么是文件" class="headerlink" title="什么是文件"></a>什么是文件</h3><p>定义：所谓“文件”，是指具有完整逻辑意义的一组相关信息的集合，它保存在磁盘上，可进行读取与修改等操作。</p><h3 id="文件的类型有哪些"><a href="#文件的类型有哪些" class="headerlink" title="文件的类型有哪些"></a>文件的类型有哪些</h3><p>文件按照不同的分类标准可进行不同的分类，下面列举几个常见分类标准：</p><p>按文件的性质和用途：</p><p>（1）系统文件：操作系统及其他系统程序（如语言的编译程序）构成系统文件的范畴。这些文件通常是可执行的目标代码及所访问的数据，用户对它们只能执行，没有读和写的权利。</p><p>（2）用户文件：用户文件是用户在软件开发过程中产生的各种文件，如源程序、目标程序代码和计算结果等。这些文件只能由文件主和被授权者使用。</p><p>（3）库文件：常用的标准子程序（如求三角函数sin、cos的子程序）、实用子程序（如对数据进行排序的子程序）等组成库文件。库文件中的文件，用户在开发过程中可以直接调用，不过用户对这些文件只能读取或执行，不能修改。</p><p>按文件的保护性质：</p><p>（1）只读文件：只允许查看的文件为只读文件。对于只读文件，使用者不能对它们进行修改，也不能运行。</p><p>（2）读写文件：这是一种允许查看和修改的文件，但不能运行。</p><p>（3）可执行文件：这是一种可以在计算机上运行的文件，以期完成特定的功能。使用者不能对它进行查看和修改。</p><p>（4）不保护文件：这是一种不设防的文件，可以任意对它进行使用、查看和修改。</p><h3 id="文件如何使用"><a href="#文件如何使用" class="headerlink" title="文件如何使用"></a>文件如何使用</h3><p>1.文件的共享</p><p>文件有两种共享方式：1.任一时刻只能有一个用户对文件进行操作 2.多个用户能同时对一个文件进行读操作</p><p>2.文件的保护</p><p>文件保护是指要防止未经授权的用户使用文件，也要防止文件主自己错误地使用文件而给文件带来破坏。通常，可以采用存取控制矩阵、存取控制表、权限表和口令等方法，来达到保护文件不受侵犯的目的。</p><p>3.文件的备份</p><p>为防止数据的意外丢失，需要对文件进行备份。</p><p>4.文件的操作</p><p>对于文件的操作主要有创建、删除、读取、写入、关闭。</p><h3 id="文件的存储方式"><a href="#文件的存储方式" class="headerlink" title="文件的存储方式"></a>文件的存储方式</h3><p>存取方式可以作为文件的分类依据。用户在访问文件时，常采用顺序存取和随机存取（也称直接存取）两种方式。</p><h3 id="文件管理是什么"><a href="#文件管理是什么" class="headerlink" title="文件管理是什么"></a>文件管理是什么</h3><p>那么，用户在以“按名存取”的方式，对自己的文件进行访问时，系统如何知道这个文件存放在哪里，如何得到有关这个文件的各种信息，以便完成用户的读&#x2F;写请求，这些涉及到对具体文件的管理问题。系统是通过文件的目录来管理文件的。</p><h3 id="如何进行文件管理"><a href="#如何进行文件管理" class="headerlink" title="如何进行文件管理"></a>如何进行文件管理</h3><p>一些概念：</p><p>1.文件控制块（FCB）</p><p>操作系统都是通过各种“控制块”对具体的管理对象实施管理的，比如进程控制块（PCB）、作业控制块（JCB）和设备控制块（DCB）等。对于文件，操作系统仍然采用这种老办法来管理。即为每一个文件开辟一个存储区，在它的里面记录着该文件的有关信息，我们把该存储区称为“文件控制块（FCB）”。于是，找到一个文件的 FCB，也就得到了这个文件的有关信息，就能够对它进行所需要的操作了。</p><p>FCB是计算机操作系统中用于管理文件的一种数据结构。它包含了关于文件的各种信息，以便于操作系统进行文件的读取、写入和管理。包含具体信息如下：</p><ul><li><p>文件名和扩展名：标识文件的唯一名称。</p></li><li><p>文件类型：指示文件的类型（例如文本文件、二进制文件等）。</p></li><li><p>文件属性：包括文件是否只读、隐藏等属性。</p></li><li><p>文件大小：指示文件所占用的存储空间大小。</p></li><li><p>文件位置：指示文件在存储介质上的物理位置。</p></li><li><p>访问权限：包括读取、写入、执行等权限。</p></li><li><p>创建日期和时间：记录文件创建的具体日期和时间。</p></li><li><p>修改日期和时间：记录文件最后一次修改的日期和时间。</p></li><li><p>访问日期和时间：记录文件最后一次被访问的日期和时间。</p></li><li><p>文件指针：用于指示当前读写位置，以便于在文件中进行定位和操作。</p></li></ul><p>2.文件目录（File Catalog）</p><p>把文件的文件控制块汇集在一起，就形成了系统的文件目录，每个文件控制块就是一个目录项，其中包含了该文件的文件名、文件属性，以及文件的数据在磁盘上的地址等信息。</p><p>一级目录结构：在系统只创建一张目录表，所有的文件都存放在这个目录表下。</p><p>优点：方便、直观。</p><p>弊端：当文件过多时，此结构不利于文件的创建、查找，由于文件不能重名，用户之间的操作容易产生冲突。</p><p>二级目录结构：在主目录下有多个用户目录，每个用户目录拥有自己的子文件。</p><p>优点：用户之间可以取重名文件，缩短了按名查找文件的时间。</p><p>弊端：但是，如果一个用户拥有很多的文件，那么在他的目录中进行查找，所花费的时间仍然会很长。另外，在二级目录结构中，用户无法对自己的文件进行再分类安排。所以，这种目录结构还是难以使用户感到满意。</p><p>树型目录结构：主目录下的每个用户目录可以有多个子目录，每个子目录又可以拥有多个子目录。</p><p>优点：大大缩短了查找文件的时间，结构清晰化。</p><p>弊端：处理大量文件时会造成目录的变化，此时需要调整树的结构。可能会导致深层的树形结构，是文件路径变长。当需要在已有的树型结构中添加新的分类或主题时，可能需要对整个结构进行调整，这可能会导致混乱。</p><p><img src="https://pica.zhimg.com/80/v2-a71d3807895f6e3c60b1a0590cd528da_720w.png?source=d16d100b"></p><p>树型目录</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;想写一写操作系统的学习小结，将自己学习的思路与想法记录下来，目标是想以尽量通俗易懂的语言将一些抽象性的概念描述出来，在记录过程中会有一些不足之处，希望大家批评指正！共勉！&lt;/p&gt;
&lt;h2 id=&quot;操作系统的启动流程&quot;&gt;&lt;a href=&quot;#操作系统的启动流程&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="操作系统" scheme="https://huang-pepsi.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>first post</title>
    <link href="https://huang-pepsi.github.io/2023/09/16/Blog/First-Post/"/>
    <id>https://huang-pepsi.github.io/2023/09/16/Blog/First-Post/</id>
    <published>2023-09-15T16:00:00.000Z</published>
    <updated>2023-09-17T04:09:23.292Z</updated>
    
    <content type="html"><![CDATA[<p>初次搭建博客，花了几个小时部署好自己的GitHub博客，过程很有收获，也还有一些盲点。<br>这是自己的一个里程碑，标志着向着专业软件工程师又前进了一步！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;初次搭建博客，花了几个小时部署好自己的GitHub博客，过程很有收获，也还有一些盲点。&lt;br&gt;这是自己的一个里程碑，标志着向着专业软件工程师又前进了一步！&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
